[
  {
    "objectID": "sorting/sort.html",
    "href": "sorting/sort.html",
    "title": "Sorting",
    "section": "",
    "text": "Here I implement sorting algorithm using insertion sort:\n\nfrom typing import List\n\ndef insertion_sort(ls: List) -&gt; List:\n    new_ls = [ls[0]]\n    for i in range(1, len(ls)):\n        pivot = ls[i]\n        \n        if pivot &gt;= new_ls[-1]:\n            new_ls.append(pivot)\n        else:\n            for j in range(len(new_ls) -1, -1, -1):\n                if pivot &gt;= new_ls[j]:\n                    new_ls.insert(j+1, pivot)\n                    break\n                elif j == 0:\n                    new_ls.insert(0, pivot)\n                elif pivot &lt; new_ls[j]:\n                    continue\n    return new_ls\n\nTrying on a random list of 10 positive ints\n\na_list = [55, 17, 23, 1, 35, 89, 43, 4, 22, 11]\nprint(insertion_sort(a_list))\n\n[1, 4, 11, 17, 22, 23, 35, 43, 55, 89]",
    "crumbs": [
      "Sorting algorithms",
      "Sorting"
    ]
  },
  {
    "objectID": "rosalind_markdowns/31_40.html",
    "href": "rosalind_markdowns/31_40.html",
    "title": "31-40",
    "section": "",
    "text": "31 Partial Permutations\n\nimport math\n\ndef count_partial_perm(n, k):\n    total = math.factorial(n) / math.factorial(n-k)\n    return int(total % 1000000)\n\n\nprint(count_partial_perm(21, 7))\n\n51200\n\n\n\n\n32 Enumerating Oriented Gene Orderings\n\ndef enumerate_oriented_genes(n: int):\n    lst = []\n    for i in range(n):\n        lst.append(i + 1)\n    print(\"Before enumerating\", lst)\n    return enumerate_helper(lst, \"\", n)\n\ndef enumerate_helper(lst, seq, k):\n    ans = \"\"\n    ## base case, stops when k == 0\n    if k == 0:\n        return seq + \"\\n\"\n    \n    for i in range(len(lst)):\n        print(lst)\n        char = lst.pop(0)\n        seq_pos = seq + str(char) + \" \"\n        ans += enumerate_helper(lst, seq_pos, k - 1)\n        \n        neg_char = char*-1\n        seq_neg = seq + str(neg_char) + \" \"\n        ans += enumerate_helper(lst, seq_neg, k - 1)\n\n        lst.append(char)\n\n    return ans\n\n\nprint(enumerate_oriented_genes(2))\n\nBefore enumerating [1, 2]\n[1, 2]\n[2]\n[2]\n[2, 1]\n[1]\n[1]\n1 2 \n1 -2 \n-1 2 \n-1 -2 \n2 1 \n2 -1 \n-2 1 \n-2 -1 \n\n\n\n\n\n33 Catalan Numbers and RNA Secondary Structures\n\n\n34 Error Correction in Reads\n\n\n35 Counting Phylogenetic Ancestors\n\ndef ancestors_count(n: int) -&gt; int:\n    if n &gt;= 4:\n        return n // 2 + n % 2\n    else:\n        return n - 2\n\n\nprint(ancestors_count(8))\n\n4\n\n\n\n\n36 k-Mer Composition\n\nfrom utils import k_mers_enumerate\ndef k_mer_composition(seq_str):\n    k_mers = k_mers_enumerate([\"A\", \"C\", \"G\", \"T\"], 4)\n    k_mers = k_mers.split(\"\\n\")[:-1]\n    print(k_mers)\n    dict = {}\n    for i in range(len(seq_str)-3):\n        seq = seq_str[i:i+4]\n        if seq not in dict:\n            dict[seq] = 1\n        else:\n            dict[seq] += 1\n    ans = \"\"\n    for k_mer in k_mers:\n        if k_mer in dict:\n            ans += str(dict[k_mer]) + \" \"\n        else:\n            ans += str(0) + \" \"\n    return ans\n\n\nwith open(\"../data/rosalind/rosalind_kmer.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[1:]\n    seq = \"\".join(text)\n    print(k_mer_composition(seq))\n\n['AAAA', 'AAAC', 'AAAG', 'AAAT', 'AACA', 'AACC', 'AACG', 'AACT', 'AAGA', 'AAGC', 'AAGG', 'AAGT', 'AATA', 'AATC', 'AATG', 'AATT', 'ACAA', 'ACAC', 'ACAG', 'ACAT', 'ACCA', 'ACCC', 'ACCG', 'ACCT', 'ACGA', 'ACGC', 'ACGG', 'ACGT', 'ACTA', 'ACTC', 'ACTG', 'ACTT', 'AGAA', 'AGAC', 'AGAG', 'AGAT', 'AGCA', 'AGCC', 'AGCG', 'AGCT', 'AGGA', 'AGGC', 'AGGG', 'AGGT', 'AGTA', 'AGTC', 'AGTG', 'AGTT', 'ATAA', 'ATAC', 'ATAG', 'ATAT', 'ATCA', 'ATCC', 'ATCG', 'ATCT', 'ATGA', 'ATGC', 'ATGG', 'ATGT', 'ATTA', 'ATTC', 'ATTG', 'ATTT', 'CAAA', 'CAAC', 'CAAG', 'CAAT', 'CACA', 'CACC', 'CACG', 'CACT', 'CAGA', 'CAGC', 'CAGG', 'CAGT', 'CATA', 'CATC', 'CATG', 'CATT', 'CCAA', 'CCAC', 'CCAG', 'CCAT', 'CCCA', 'CCCC', 'CCCG', 'CCCT', 'CCGA', 'CCGC', 'CCGG', 'CCGT', 'CCTA', 'CCTC', 'CCTG', 'CCTT', 'CGAA', 'CGAC', 'CGAG', 'CGAT', 'CGCA', 'CGCC', 'CGCG', 'CGCT', 'CGGA', 'CGGC', 'CGGG', 'CGGT', 'CGTA', 'CGTC', 'CGTG', 'CGTT', 'CTAA', 'CTAC', 'CTAG', 'CTAT', 'CTCA', 'CTCC', 'CTCG', 'CTCT', 'CTGA', 'CTGC', 'CTGG', 'CTGT', 'CTTA', 'CTTC', 'CTTG', 'CTTT', 'GAAA', 'GAAC', 'GAAG', 'GAAT', 'GACA', 'GACC', 'GACG', 'GACT', 'GAGA', 'GAGC', 'GAGG', 'GAGT', 'GATA', 'GATC', 'GATG', 'GATT', 'GCAA', 'GCAC', 'GCAG', 'GCAT', 'GCCA', 'GCCC', 'GCCG', 'GCCT', 'GCGA', 'GCGC', 'GCGG', 'GCGT', 'GCTA', 'GCTC', 'GCTG', 'GCTT', 'GGAA', 'GGAC', 'GGAG', 'GGAT', 'GGCA', 'GGCC', 'GGCG', 'GGCT', 'GGGA', 'GGGC', 'GGGG', 'GGGT', 'GGTA', 'GGTC', 'GGTG', 'GGTT', 'GTAA', 'GTAC', 'GTAG', 'GTAT', 'GTCA', 'GTCC', 'GTCG', 'GTCT', 'GTGA', 'GTGC', 'GTGG', 'GTGT', 'GTTA', 'GTTC', 'GTTG', 'GTTT', 'TAAA', 'TAAC', 'TAAG', 'TAAT', 'TACA', 'TACC', 'TACG', 'TACT', 'TAGA', 'TAGC', 'TAGG', 'TAGT', 'TATA', 'TATC', 'TATG', 'TATT', 'TCAA', 'TCAC', 'TCAG', 'TCAT', 'TCCA', 'TCCC', 'TCCG', 'TCCT', 'TCGA', 'TCGC', 'TCGG', 'TCGT', 'TCTA', 'TCTC', 'TCTG', 'TCTT', 'TGAA', 'TGAC', 'TGAG', 'TGAT', 'TGCA', 'TGCC', 'TGCG', 'TGCT', 'TGGA', 'TGGC', 'TGGG', 'TGGT', 'TGTA', 'TGTC', 'TGTG', 'TGTT', 'TTAA', 'TTAC', 'TTAG', 'TTAT', 'TTCA', 'TTCC', 'TTCG', 'TTCT', 'TTGA', 'TTGC', 'TTGG', 'TTGT', 'TTTA', 'TTTC', 'TTTG', 'TTTT']\n417 417 349 430 365 405 410 400 350 386 380 378 378 419 398 363 368 370 383 354 396 378 384 375 393 387 381 381 370 388 386 401 377 388 380 411 386 370 377 366 388 383 401 385 376 394 359 372 358 406 382 369 385 403 401 394 361 357 365 403 385 394 359 402 400 381 383 384 364 386 369 372 399 401 394 373 364 364 349 393 372 401 389 374 377 420 371 340 367 370 397 387 393 397 376 369 389 391 375 372 374 375 393 388 362 425 357 404 388 367 410 386 370 368 399 403 376 367 427 358 383 388 365 378 366 396 381 384 388 388 405 363 366 381 368 392 427 346 381 353 412 370 349 409 381 376 411 370 374 354 381 373 372 374 364 410 399 362 380 365 370 377 359 381 408 389 379 393 392 376 348 377 392 379 332 386 410 389 390 376 394 407 363 389 388 355 342 383 409 354 367 381 408 394 357 381 380 361 395 381 380 366 402 397 361 430 390 375 427 344 384 372 389 356 385 447 395 399 406 373 378 381 372 392 408 351 394 376 370 348 371 359 345 384 387 323 409 413 367 367 402 354 374 408 372 400 382 382 397 348 367 392 378 392 397 393 \n\n\n\n\n37 Speeding Up Motif Finding\n\ndef speed_up_motif(seq: str):\n    ans = \"\"\n\n    ## construct 0 array\n    arr = []\n\n    for i in range(len(seq)):\n        arr.append(0)\n\n    for i in range(1, len(seq)):\n        cumm = 0\n        for j in range(len(seq)):\n            if j + i &lt; len(seq) and seq[j] == seq[j+i]:\n                cumm += 1\n                if cumm &gt; arr[j+i]:\n                    arr[j+i] = cumm\n            else:\n                break\n    \n    with open(\"../data/results/results_motif.txt\", \"w\") as f:\n        ans = \"\"\n        for each in arr:\n            ans += str(each) + \" \"\n        f.write(ans)\n    return ans\n\n\nprint(speed_up_motif(\"AAACAAAAAAGCTGATAAAAGATTGCC\"))\n\n0 1 2 0 1 2 3 3 3 3 0 0 0 0 1 0 1 2 3 3 0 1 0 0 0 0 0 \n\n\n\n\n38 Finding a Shared Spliced Motif\n\n\n39 Ordering Strings of Varying Length Lexicographically\n\nfrom typing import List\ndef helper(results_str, to_multi):\n    new = []\n    results_str = [\"\"] + results_str\n    for i in range(len(to_multi)):\n        for j in range(len(results_str)):\n            new.append(to_multi[i] + results_str[j])\n    return new\n\ndef order_strings_lex(results_str, seq_str: List, k: int):\n    to_multi = [] + seq_str\n    if k == 1:\n        return results_str    \n    return helper(order_strings_lex(results_str, seq_str, k - 1), to_multi)\n\n\nwith open(\"../data/rosalind/rosalind_lexv.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    li = list(text[0].split(\" \"))\n    num = int(text[1])\n    ans = order_strings_lex(li, li, num)\n\nwith open(\"../data/results/results_lexv.txt\", \"w\") as f:\n    for each in ans:\n        f.write(each)\n        f.write(\"\\n\")\n\n\n\n40 Maximum Matchings and RNA Secondary Structures\n\ndef maximum_matching(seq: str):\n    dict = {}\n    for char in seq:\n        if char not in dict:\n            dict[char] = 1\n        else:\n            dict[char] += 1\n\n    max_AU, min_AU = max(dict[\"A\"], dict[\"U\"]), min(dict[\"A\"], dict[\"U\"])\n    max_GC, min_GC = max(dict[\"G\"], dict[\"C\"]), min(dict[\"G\"], dict[\"C\"])\n\n    print(dict)\n\n    AU_matching = math.factorial(max_AU) // math.factorial(max_AU-min_AU)\n    GC_matching = math.factorial(max_GC) // math.factorial(max_GC-min_GC)\n    num_matching = AU_matching*GC_matching\n    return num_matching\n\n\nwith open(\"../data/rosalind/rosalind_mmch.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[1:]\n    seq = \"\".join(text)\n    print(maximum_matching(seq))\n\n{'A': 18, 'G': 31, 'U': 20, 'C': 18}\n1606334820229118893611815798833152000000000",
    "crumbs": [
      "Rosalind",
      "31-40"
    ]
  },
  {
    "objectID": "rosalind_markdowns/1_10.html",
    "href": "rosalind_markdowns/1_10.html",
    "title": "1-10",
    "section": "",
    "text": "1 Counting DNA nucleotides\n\ndef DNA_count(sequence: str) -&gt; str:\n    \"\"\"\n        This function counts the number of nucleotides present in a given DNA sequence\n        -----\n        Parameters:- sequence (str): the DNA sequence\n        -----\n        Returns- counts (str): a string represents the counts of A, C, G, T in their respective order \n    \"\"\"\n\n    answer = \"\"\n    dna_count = {\"A\" : 0, \"C\" : 0, \"G\": 0, \"T\" : 0}\n    for i in range(len(sequence)):\n        nucleotide = sequence[i]\n        dna_count[nucleotide] += 1\n    \n    for nucleotide in dna_count.values():\n        answer += str(nucleotide) + \" \"\n\n    return answer[:-1]\n\n\n## Test case:\nprint(DNA_count(\"AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTG\"))\n\n17 10 15 20\n\n\n\n\n2 Transcribing DNA to RNA\n\ndef transcription(DNA_seq: str) -&gt; str:\n    \"\"\"\n    This function transcribes a DNA sequence into an RNA sequence\n    -----\n    Parameters:\n    - DNA_seq (str): a DNA sequence string to be transcribed\n    \n    -----\n    Returns:\n    - RNA_seq (str): the transcribed RNA sequence\n    \"\"\"\n    return DNA_seq.replace(\"T\", \"U\")\n\n\nprint(transcription(\"GATGGAACTTGACTACGTAAATT\"))\n\nGAUGGAACUUGACUACGUAAAUU\n\n\n\n\n3 Complementing a strand of DNA\n\ndef DNA_complementary(DNA_seq: str) -&gt; str:\n    \"\"\"\n        This function returns the complementary strand of a given DNA sequence\n        -----\n        Parameters:\n        - DNA_seq (str): the DNA sequence string\n        -----\n        Returns:\n        - DNA_com (str): the complementary strand\n    \"\"\"\n    complementary = {\"A\" : \"T\", \"T\" : \"A\", \"C\" : \"G\", \"G\" : \"C\"}\n    DNA_com = \"\"\n    for nucleotide in DNA_seq:\n        DNA_com += complementary[nucleotide]\n    return DNA_com[::-1]\n\n\nprint(DNA_complementary(\"AAAACCCGGT\"))\n\nACCGGGTTTT\n\n\n\n\n4 Rabbits & Recurrence Relations\n\ndef wascally_wabbits(n: int, k: int)-&gt; int:\n    \"\"\"\n        This function counts the number of rabbits in the n-th generation,\n        provided that each pair gives birth to k-pairs\n        -----\n        Parameters:\n        - n (int): the number of generations\n        - k (int): the number of rabbits pairs one give birth to\n    \"\"\"\n    if n &gt; 2:\n        return wascally_wabbits(n - 2, k)*k + wascally_wabbits(n - 1, k)\n    else:\n        return 1\n\n\nprint(\"After 6 gens, provided that a pair gives birth to 6 pairs we have:\")\nprint(wascally_wabbits(6, 3))\n\nprint(\"After 29 gens, provided that a pair gives birth to 4 pairs we have:\")\nprint(wascally_wabbits(29, 4))\n\nAfter 6 gens, provided that a pair gives birth to 6 pairs we have:\n40\nAfter 29 gens, provided that a pair gives birth to 4 pairs we have:\n170361678269\n\n\n\n\n5 Computing GC Contents\n\ndef GC_contents(FASTA: str) -&gt; str:\n    \"\"\"\n        This function computes the GC-content of a given FASTA file and returns\n        the sequences with the highest GC contents.\n        The GC-content is defined as the percentage of G/C nucleotide among\n        all nucleotides in the string\n        -----\n        Parameters:\n        - FASTA (str): the sequences in FASTA formats\n        -----\n        Returns:\n        - (str): a string represents (1) Sequence identifier, (2) GC %\n    \"\"\"\n    fasta_seq = FASTA.split(\"&gt;\")\n    GC_content = {}\n    for a_seq in fasta_seq:\n        if len(a_seq) == 0:\n            continue\n        seq = a_seq.split(\"\\n\")\n        GC_count = 0\n        for char in seq[1]:\n            if char == \"C\" or char == \"G\":\n                GC_count +=1\n        GC_content[seq[0]] = GC_count/len(seq[1])\n    print(GC_content)\n    results = sorted(GC_content.items())[0]\n    return results[0] + \"\\n\" + str(results[1])\n\n\nwith open(\"../data/rosalind/rosalind_qc.txt\", \"r\") as file:\n  print(GC_contents(file.read()))\n\n{'Rosalind_6404': 0.5375, 'Rosalind_5959': 0.5357142857142857, 'Rosalind_0808': 0.6091954022988506}\nRosalind_0808\n0.6091954022988506\n\n\n\n\n6 Counting Point Mutations\n\ndef point_mutations(s_seq: str, t_seq: str) -&gt; int:\n    \"\"\"\n        This function counts the number of point mutations on a sequence using\n        its reference sequence\n        -----\n        Parameters:\n        - s_seq (str): the reference DNA sequence\n        - t_seq (str): the sequence to compute mutations\n        -----\n        Returns:\n        - (int): the number of point mutations in t_seq\n    \"\"\"\n    if (len(s_seq) != len(t_seq)):\n        return 0\n    else:\n        point_mut = 0\n        for i in range(len(s_seq)):\n            if s_seq[i] != t_seq[i]:\n                point_mut += 1\n    return point_mut\n\n\nmut_counts = point_mutations(\"GAGCCTACTAACGGGAT\", \"CATCGTAATGACGGCCT\")\nprint(\"The number of mutations:\", mut_counts)\n\nThe number of mutations: 7\n\n\n\n\n7 Mendel’s First Law\n\ndef mendelian(k: int, m: int, n: int) -&gt; float:\n    \"\"\"\n        This function calculates the probability of two randomly selected mating organisms\n        producing an individual possessing a dominant allele\n        -----\n        Parameters:\n        - k (int): number of dominants homozygous individuals (AA)\n        - m (int): number of heterozygous individuals (Aa)\n        - n (int): number of recessive homozygous individuals (aa)\n        -----\n        Returns:\n        - (float): the probability of dominants homozygous individuals\n        in the population for the next generation\n    \"\"\"\n    total =  k + m + n\n    hetero_prob = 0.25*(m/total)*(m-1)/(total-1) + (m/total)*n/(total-1)\n    homo_recessive_prob = (n/total) * ((n-1)/(total-1))\n    return 1 - hetero_prob - homo_recessive_prob\n\n\nprint(mendelian(26, 19, 16))\n\n0.8280054644808743\n\n\n\n\n8 Translation of RNA to protein\n\ndef translation(RNA_seq: str) -&gt; str:\n    \"\"\"\n        This function translates the RNA sequence into a protein using the\n        codon table (in data/ref folder).\n        -----\n        Parameters:\n        - RNA_seq (str): an RNA sequence to be translated\n        -----\n        Returns:\n        - protein (str): the encoded protein sequence\n    \"\"\"\n    with open(\"../data/ref/codon.txt\", \"r\") as file:\n        text = [line.replace(\"\\n\", \"\").split(\" \") for line in file.readlines()]\n        codon_table = {}\n        protein = \"\"\n        for line in text:   \n            line = [x for x in line if x != '']\n            for i in range(len(line) // 2):\n                codon_table[line[i*2]] = line[i*2+1]\n        for i in range(len(RNA_seq) // 3):\n            codon = RNA_seq[i*3:i*3+3]\n            protein += codon_table[codon] if codon_table[codon] != \"Stop\" else \"\"\n    return protein\n\n\nprint(translation(\"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\"))\n\nMAMAPRTEINSTRING\n\n\n\n\n9 Finding a Motif in DNA\n\ndef motif_check(s_str: str, t_str: str) -&gt; str:\n    \"\"\"\n        This function finds a motif within a DNA sequence.\n        -----\n        Parameters:\n        - s_str (str): the DNA sequence \n        - t_str (str): the motif to look up\n        -----\n        Returns:\n        - (str): a string of starting position of the motif\n    \"\"\"\n    answer = \"\"\n    for i in range(len(s_str) - len(t_str)):\n        t_len = len(t_str)\n        if s_str[i:i + t_len] == t_str:            \n            answer += str(i+1) + \" \"\n    return answer[:-1]\n\n\nprint(motif_check(\"GATATATGCATATACTT\", \"ATAT\"))\n\n2 4 10\n\n\n\n\n10 Consensus and Profile\n\nfrom typing import List\nimport pandas as pd\nimport numpy as np\n\ndef consensus_and_profile(file):\n    \"\"\"\n        This function construct a consensus and a profile matrix from multiple\n        DNA sequences. The answer is written into a new file.\n        -----\n        Parameters:\n        - file\n    \"\"\"\n    DNA_len = 942\n    a_dict = {\"A\" : np.zeros(DNA_len), \"C\" : np.zeros(DNA_len), \n                    \"G\" : np.zeros(DNA_len), \"T\" : np.zeros(DNA_len)}\n    with open(file, \"r\") as f:\n        text = f.read().split(\"&gt;\")\n        for DNA_seq in text:\n            DNA_seq = \"\".join(DNA_seq.split(\"\\n\")[1:])\n            if len(DNA_seq) == 0:\n                continue\n            for i in range(DNA_len):\n                nucleotide = DNA_seq[i]\n                a_dict[nucleotide][i] += 1\n        profile = []\n        for nucleotide in a_dict.values():\n            profile.append(nucleotide)\n        profile = pd.DataFrame(profile, index=[\"A\", \"C\", \"G\", \"T\"])\n        consensus = \"\"\n        for i in range(DNA_len):\n            max_nucleotide = profile[i].idxmax()\n            consensus +=str(max_nucleotide)\n    with open(\"../data/results/cons_result.txt\", \"w\") as file:\n        file.write(consensus + \"\\n\")\n        for nucleotide, values in a_dict.items():\n            file.write(nucleotide + \": \")\n            for value in values:\n                file.write(str(int(value)) + \" \")\n            file.write(\"\\n\")\n\n\nconsensus_and_profile(\"../data/rosalind/rosalind_cons.txt\")",
    "crumbs": [
      "Rosalind",
      "1-10"
    ]
  },
  {
    "objectID": "reading/paper.html",
    "href": "reading/paper.html",
    "title": "anti-PD1 treatment for BC patients",
    "section": "",
    "text": "Full title: A single-cell map of intratumoral changes during anti-PD1 treatment of patients with breast cancer\nDOI: https://doi.org/10.1038/s41591-021-01323-8",
    "crumbs": [
      "Reading comprehension",
      "anti-PD1 treatment for BC patients"
    ]
  },
  {
    "objectID": "reading/paper.html#about-single-cell-rna-seq",
    "href": "reading/paper.html#about-single-cell-rna-seq",
    "title": "anti-PD1 treatment for BC patients",
    "section": "About single-cell RNA-seq",
    "text": "About single-cell RNA-seq\nSingle-cell RNA-seq consists of the following steps:",
    "crumbs": [
      "Reading comprehension",
      "anti-PD1 treatment for BC patients"
    ]
  },
  {
    "objectID": "reading/paper.html#study-overview",
    "href": "reading/paper.html#study-overview",
    "title": "anti-PD1 treatment for BC patients",
    "section": "Study overview",
    "text": "Study overview\nThis paper investigates the use of anti-PD1 on breast cancer patients",
    "crumbs": [
      "Reading comprehension",
      "anti-PD1 treatment for BC patients"
    ]
  },
  {
    "objectID": "reading/paper.html#investigative-questions",
    "href": "reading/paper.html#investigative-questions",
    "title": "anti-PD1 treatment for BC patients",
    "section": "Investigative questions",
    "text": "Investigative questions\n\nWhat information to gather from the paper to re-analyze the paper and use the data for future big data research purposes\nRe-analyzing this paper requires:\nData:\n\nRaw-sequencing reads of scRNA-seq, scTCR-seq and CITE-seq. The link to those data can be found\ngnomAD database is used to filter tumor exome-seq data for somatic mutations.\n\n\n\nCan you provide an explanation of how single-cell RNA sequencing experiments were specifically designed to study the topic?\nThe sequencing experiments were designed as follow:\n\nBiopsies were obtained pre-treatment and on-treatment and then subjected to single-cell disassociation on ice. The cells are then filtered after removal of red blood cells and number of living cells were determined using a LUNA cell counter.\nSingle-cell TCR-seq and 5’ gene expression profiling was performed with upto 5000 cells are loaded to the cartridge for each sample.\nPerformed subcluster T cells from pre- and on-treatment samples using the integration pipeline of Seurat.\n\n\n\nFrom the paper, list the major cell types and their marker genes\nMajor cell types:\n\nT cells, markers are: INPP5F and GPR25, ZEB2 (T_{H1}), CCR7 and LEF1 (naive T cells markers)\nDendritic cells, markers are: CCR7, CCL19\nFibroblast\nMyeloid cell\nB cell\n\n\n\nFrom the paper, list the cell subtypes\nT cells have the following cell subtypes:\n\nExperienced T cells (T_{EX}), which were further split into type-1 helper (T_{H1}) and follicular helper (T_{FH})\nResident-memory T cells (T_{RM})\nActivated effector/memory T cells (T_{EMRA})\n\n\n\nWhat information or data was NOT further investigated by the author that might hold potential for significant findings?\nFrom the paper, I think that we can investigate further on the following:\n\n\n\n\n\n\nWhat new knowledge or insights did you acquire from reading this paper, stated in your own words?\nA lot, I attempted to visualize what I learned below:\n\nOn various T-cell types:\nThe process of :\nCell-protein interaction:",
    "crumbs": [
      "Reading comprehension",
      "anti-PD1 treatment for BC patients"
    ]
  },
  {
    "objectID": "rosalind_markdowns/11_20.html",
    "href": "rosalind_markdowns/11_20.html",
    "title": "11-20",
    "section": "",
    "text": "11 Mortal Fibonacci Rabbits\n\ndef mortal_rabbits(n: int, m: int):\n    \"\"\"\n\n    \"\"\"\n    ls = [1, 0, 1]\n    for j in range(3, m):\n        ls.append(0)\n    for i in range(3, n):\n        new_ls = []\n        summ = sum(ls[1:])\n        new_ls.append(summ)\n        for j in range(1, len(ls)):\n            new_ls.append(ls[j-1])\n        ls = new_ls\n    return sum(ls[:])\n\n\nprint(mortal_rabbits(89, 16))\n\n1753129196882635810\n\n\n\n\n12 Overlap graphs\n\ndef overlap_graph(file, k:int):\n    with open(file, \"r\") as f:\n        text = f.read().split(\"&gt;\")[1:]\n        answer = \"\"\n        graph_dict = {}\n        for string in text:\n            strs = string.split(\"\\n\")\n            graph_dict[strs[0]] = \"\".join(strs[1:])\n        for key, value in graph_dict.items():\n            suffix = value[-k:]\n            for key_i, value_i in graph_dict.items():\n                if key_i != key:\n                    prefix_i = value_i[:k]\n                    if suffix == prefix_i:\n                        answer += key + \" \" + key_i + \"\\n\"\n    with open(\"../data/results/results_graph.txt\", \"w\") as f:\n        f.write(answer)\n\n\noverlap_graph(\"../data/rosalind/rosalind_grph.txt\", 3)\n\n\n\n13 Calculating Expected Offspring\n\nfrom typing import List\n\ndef expected_offstring(ls: List) -&gt; float:\n    expected_child_num = 0\n    phenotype = [1, 1, 1, 0.75, 0.5, 0]\n    for i in range(len(ls)):\n        expected_child_num += float(ls[i])*phenotype[i]\n    return expected_child_num*2\n\n\nwith open(\"../data/rosalind/rosalind_iev.txt\", \"r\") as f:\n    text = f.read().split(\" \")\n    print(expected_offstring(text))\n\n141399.0\n\n\n\n\n14 Finding a Shared Motif\n\nimport re\ndef shared_motif(file):\n    with open(file, \"r\") as f:\n        text = f.read().split(\"&gt;\")[1:]\n        seq_dicts = []\n        for string in text:\n            strs = string.split(\"\\n\")\n            seq_dicts.append(\"\".join(strs[1:]))\n        motifs_ls = longest_common_substr(seq_dicts[0], seq_dicts[1])    \n        lsss = motifs_ls\n        for motif in motifs_ls:\n            for seq in seq_dicts[2:]:\n                if motif not in seq:\n                    lsss.remove(motif)\n                    break\n        return lsss[0]\n\ndef longest_common_substr(str_1, str_2):\n    common_substr = \"\"\n    substrs = []\n    for i in range(len(str_1), 1, -1):\n        rang = len(str_1) - i + 1\n        for j in range(rang):\n            pattern = str_1[j:j+i]\n            if pattern in str_1 and pattern in str_2:\n                common_substr = str_1[j:j+i]\n                substrs.append(common_substr)\n\n    return substrs\n\n\nprint(shared_motif(\"../data/rosalind/rosalind_grph.txt\"))\n\nTTCTAATCGATCACCAGGGTAACAGATTCTGCCTTAGGTAGCCTTGCTAACACCAGTGACGATATGTCCCATAGGGCTCTCAAAGTGAACGCTGATGATGGAGTGTTAGCGTGAGCGAATTAATATTTTCGAGGATCCGGA\n\n\n\n\n15 Independent Alleles\n\nimport math\ndef independent_alleles(k: int, N: int) -&gt; float:\n    total = 0.0\n    for i in range(N, 2**k + 1):\n        n_fact = math.factorial(2**k)\n        n_k_fact = (math.factorial(i)*math.factorial(2**k-i))\n        binom = n_fact/n_k_fact\n        prob = (1/4)**(i) * (3/4)**(2**k-i) * binom\n        total += prob\n    return total\n\n\nprint(independent_alleles(6, 16))\n\n0.5478689355957752\n\n\n\n\n16 Finding a protein motif\n\nimport requests\nimport re\ndef protein_motif(ls: List) -&gt; str:\n    answer = \"\"\n    pattern = re.compile(\"(?=(N[^P](S|T)[^P]))\")\n    for protein in ls:\n        print(f\"Looking for protein {protein}\")\n        if \"_\" in protein:\n            protein_id = protein.split(\"_\")[0]\n        else:\n            protein_id = protein\n        info = requests.get(f\"http://www.uniprot.org/uniprot/{protein_id}.fasta\").text\n        protein_seq = \"\".join(info.split(\"\\n\")[1:])\n        locations = \"\"\n\n        for m in pattern.finditer(protein_seq):\n            locations += str(m.start() + 1) + \" \"\n        if locations == \"\":\n            continue\n        answer += protein + \"\\n\" + locations + \"\\n\"\n\n    with open(\"../data/results/results_protein_motif.txt\", \"w\") as f:\n        f.write(answer)\n    return answer\n\n\n## Test case\nwith open(\"../data/rosalind/rosalind_mprt.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    print(text)\n    # print(protein_motif(text))\n\n['Q4FZD7', 'Q8R1Y2', 'Q90304_C166_CARAU', 'Q32LI2', 'P01044_KNH1_BOVIN', 'P10643_CO7_HUMAN', 'P80069_A45K_MYCBO', 'P28314_PER_COPCI', 'P04233_HG2A_HUMAN', 'B4S2L7', 'Q07287_ZPB_PIG', 'P05783_K1CR_HUMAN', 'B3ET80', 'P04921_GLPC_HUMAN']\n\n\n\n\n17 Inferring mRNA from protein\n\ndef mRNA_inference(protein_seq:str) -&gt; int:\n    total = 1\n    with open(\"../data/ref/codon.txt\", \"r\") as file:\n        text = [line.replace(\"\\n\", \"\").split(\" \") for line in file.readlines()]\n        codon_table = {}\n\n        for line in text:   \n            line = [x for x in line if x != '']\n            \n            for i in range(len(line) // 2):\n                symbol = line[i*2+1]\n                amino_acid = line[i*2]\n                if symbol not in codon_table:\n                    codon_table[symbol] = [amino_acid]\n                else:\n                    codon_table[symbol].append(amino_acid)\n\n    for protein in protein_seq:\n        total *= len(codon_table[protein])\n\n    return total*3 % 1000000\n\n\nwith open(\"../data/rosalind/rosalind_mrna.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    text = \"\".join(text)\n    # print(mRNA_inference(text))\n\n\n\n18 Open Reading Frames\n\nfrom utils import DNA_complementary, transcription\ndef get_codon_table(aa_first=False):\n    with open(\"../data/ref/codon.txt\", \"r\") as file:\n        text = [line.replace(\"\\n\", \"\").split(\" \") for line in file.readlines()]\n        codon_table = {}\n        for line in text:   \n            line = [x for x in line if x != '']\n            if aa_first == True:\n                for i in range(len(line) // 2):\n                    codon_table[line[i*2]] = line[i*2+1]\n            else: \n                for i in range(len(line) // 2):\n                    symbol = line[i*2+1]\n                    amino_acid = line[i*2]\n                    if symbol not in codon_table:\n                        codon_table[symbol] = [amino_acid]\n                    else:\n                        codon_table[symbol].append(amino_acid)\n    return codon_table\n\ndef orf(DNA_seq):\n    ls_of_seq = []\n    codon_table = get_codon_table()\n    reverse_codon_table = get_codon_table(aa_first=True)\n    stop_codon = codon_table[\"Stop\"]\n    start_codon = \"AUG\"\n    DNA_com = DNA_complementary(DNA_seq)\n    RNA_seq = transcription(DNA_seq)\n    RNA_seq_reverse = transcription(DNA_com)\n\n    for codon in stop_codon:\n        pattern = re.compile(start_codon)\n        for m in pattern.finditer(RNA_seq):\n            seq = \"\"\n            i = m.start()\n            notEnd = True\n            while notEnd:\n                _codon = RNA_seq[i:i+3]\n                i += 3\n                if _codon in stop_codon:\n                    ls_of_seq.append(seq)\n                    break\n                if i &gt;= len(RNA_seq):\n                    break\n                seq += reverse_codon_table[_codon]\n        for m in pattern.finditer(RNA_seq_reverse):\n            seq = \"\"\n            i = m.start()\n            notEnd = True\n            while notEnd:\n                _codon = RNA_seq_reverse[i:i+3]\n                i += 3\n                if _codon in stop_codon:\n                    ls_of_seq.append(seq)\n                    break\n                if i &gt;= len(RNA_seq_reverse):\n                    break\n                seq += reverse_codon_table[_codon]\n    return \"\\n\".join(set(ls_of_seq))\n\n\nwith open(\"../data/rosalind/rosalind_orf.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    text = \"\".join(text)\n    print(orf(text))\n\nML\nMAAQTVAVITSK\nMTVSKLWYPELAGLAWH\nMALKGVTSAPVPRSDVIPRSIGVQDGPGGSTSHLPHTPPTFRLLKHS\nMRDRQAQDTTILIRSSRFFVYTILVFLLHLVVLL\nMPAASVAFRVKRLSGAETRELYKQRTVMTVSKLWYPELAGLAWH\nMACLSPGNSRDES\nM\nMMADPNVKVYFDQLY\nMLVEYNRISYASKDEKLAVYAGDGRWSPRARLERQSTAVSHLSAVQAHS\nMPCETGKLRIPQF\nMREMGGGAPGPVLNANRPRYHI\nMGGGAPGPVLNANRPRYHI\nMKAKALSLYWSDVPKYVGPLATAALANAAVASGPTLPHLKMLVEYNRISYASKDEKLAVYAGDGRWSPRARLERQSTAVSHLSAVQAHS\nMLDHWLPLR\nMRI\nMLLSSMAAQTVAVITSK\nMWVLARLDTSAIIRYGTARFVDISITDQSRLLHWDPPSFTRDNGHGLGGHAR\nMADPNVKVYFDQLY\nMKCNKP\nMLQKTKSWRCMREMGGGAPGPVLNANRPRYHI\nMVVLAQSIKEQNHPWVATACYTSCNGLSFPRQLKG\nMLDRSIISSFACFTQGARRSRAAVYQRLEVYPRRSRSTTT\nMGRRGLWILV\nMFRSMLDHWLPLR\n\n\n\n\n19 Enumerating Gene Orders\n\ndef enumerate_gene_orders(k:int) -&gt; str:\n    answer = \"\"\n    answer += str(point_mutation_enum(k)) + \"\\n\"\n    answer += point_mutation_ways(k)\n    answer = answer.split(\"\\n\")\n    final = answer[0] + \"\\n\"\n    for line in answer[1:]:\n        line = line[1:] + \"\\n\"\n        final += line\n    with open(\"../data/results/results_perm\", \"w\") as f:\n        f.write(final)\n\ndef point_mutation_enum(k: int):\n    if k == 1:\n        return 1\n    else: \n        return k * point_mutation_enum(k-1)\n\ndef point_mutation_ways(k: int):\n    lst = []\n    cur = \"\"\n    for i in range(k):\n        lst.append(str(i+1))\n    cur =  recurse(\"\", lst)\n    return cur\n\ndef recurse(cur, lst):\n    answer = \"\"\n    if len(lst) == 0:\n        return cur + \"\\n\"\n    for i in range(len(lst)):\n        nextChar = lst.pop(i)\n        pr = recurse(cur + \" \" + nextChar, lst)\n        lst.insert(i, nextChar)\n        answer += pr\n    return answer\n\n\nenumerate_gene_orders(6)\n\n\n\n20 Calculating Protein Mass\n\ndef get_mass(file):\n    mass_dict = {}\n    with open(file, \"r\") as f:\n        text = f.read().split(\"\\n\")\n        for line in text:\n            line = line.split(\" \")\n            mass_dict[line[0]] = line[-1]\n    return mass_dict\n\ndef protein_mass(seq: str)-&gt;float:\n    total_mass = 0.0\n    mass_dict = get_mass(\"../data/ref/mass.txt\")\n    for aa in seq:\n        total_mass += float(mass_dict[aa])\n    return total_mass\n\n\nwith open(\"../data/rosalind/rosalind_mass.txt\", \"r\") as file:\n    print(protein_mass(file.read()))\n\n102582.32414000055",
    "crumbs": [
      "Rosalind",
      "11-20"
    ]
  },
  {
    "objectID": "rosalind_markdowns/21_30.html",
    "href": "rosalind_markdowns/21_30.html",
    "title": "21-30",
    "section": "",
    "text": "21 Locating Restriction Sites\n\nfrom utils import DNA_complementary, transcription\ndef restriction_sites(seq_str: str):\n    len_lst = [12, 10, 8, 6, 4]\n    answer = \"\"\n    for i in range(len(seq_str)):\n        # print(i)\n        for length in len_lst:\n            if i + length &lt;= len(seq_str):\n                substr = seq_str[i:i+length]\n                if check_palindrome(substr):\n                    answer += str(i + 1) + \" \" + str(length) + \"\\n\"\n                    continue\n                continue\n    return answer\ndef check_palindrome(substr):\n    if len(substr) == 0:\n        return True\n    else:\n        if DNA_complementary(substr[0]) == substr[-1]:\n            # print(substr, substr[1:len(substr)-1])\n            return check_palindrome(substr[1:len(substr)-1])\n        else:\n            return False\n\n\nwith open(\"../data/rosalind/rosalind_repv.txt\", \"r\") as file:\n    text = \"\".join(file.read().split(\"\\n\"))\n    print(restriction_sites(text))\n\n1 4\n13 4\n22 8\n23 6\n24 4\n39 4\n57 4\n62 4\n63 4\n132 8\n133 6\n134 4\n141 4\n142 4\n175 4\n195 8\n196 6\n197 4\n200 4\n206 4\n218 4\n220 6\n221 8\n221 4\n222 6\n223 4\n225 4\n228 4\n234 4\n236 8\n237 6\n238 4\n261 6\n262 4\n271 4\n274 4\n307 4\n318 4\n341 4\n419 4\n442 6\n443 4\n461 12\n462 10\n463 8\n464 6\n465 4\n491 4\n520 4\n534 4\n544 6\n545 4\n548 6\n549 4\n609 4\n611 4\n631 6\n632 4\n639 6\n640 4\n652 4\n654 4\n703 10\n704 8\n705 6\n706 4\n715 6\n716 4\n731 10\n732 8\n733 6\n733 4\n734 4\n735 4\n758 4\n761 6\n762 4\n790 4\n800 4\n801 4\n822 8\n823 6\n824 4\n846 6\n847 4\n852 6\n853 4\n858 4\n886 4\n901 4\n929 4\n\n\n\n\n\n22 RNA Splicing\n\nimport re\nfrom utils import transcription, translation\ndef RNA_splicing(file) -&gt; str:\n    RNA_dict = {}\n    with open(file, \"r\") as f:\n        text = f.read().split(\"&gt;\")\n        final_rosalind = []\n        for rosalind in text:\n            if rosalind != \"\":\n                rosalind = rosalind.split(\"\\n\")[1:]\n                final_rosalind.append(\"\".join(rosalind))\n        for i in range(len(final_rosalind)):\n            RNA_dict[i] = final_rosalind[i]\n        pivot = RNA_dict[0]\n        for j in range(1, len(RNA_dict)):\n            pattern = re.compile(RNA_dict[j])\n            m = pattern.search(pivot)\n            if m != None:\n                pivot = pivot[:m.start()] + pivot[m.end():]\n        RNA_seq = transcription(pivot)\n    return translation(RNA_seq)\n\n\nwith open(\"../data/results/answer_rosalind_splc.txt\", \"w\") as f:\n    f.write(RNA_splicing(\"../data/rosalind/rosalind_splc.txt\"))\n\n\n\n23 Enumerating k-mers Lexicographically\n\nfrom typing import List\n\ndef k_mers_enumerate(seq_str: List, k: int):\n    cur = \"\"\n    cur = recurse(\"\", seq_str, k)\n    return cur\ndef recurse(cur, lst, k):\n    answer = \"\"\n    if k == 0:\n        return cur + \"\\n\"\n    for j in range(len(lst)):\n        nextChar = lst[j]\n        pr = recurse(cur + nextChar, lst, k - 1)\n        answer += pr\n    return answer\n\n\nprint(k_mers_enumerate([\"A\", \"C\", \"G\", \"T\"], 2))\n\nAA\nAC\nAG\nAT\nCA\nCC\nCG\nCT\nGA\nGC\nGG\nGT\nTA\nTC\nTG\nTT\n\n\n\n\n\n24 Genome assembly shortest superstring\n\n\n25 Perfect Matchings\n\nimport math\ndef perfect_matching(seq: str) -&gt; int:\n    A_counts = 0\n    G_counts = 0\n    for char in seq:\n        if char == \"A\":\n            A_counts += 1\n        elif char == \"G\":\n            G_counts += 1\n\n    return math.factorial(A_counts) * math.factorial(G_counts)\n\n\nwith open(\"../data/rosalind/rosalind_pmch.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[1:]\n    text = \"\".join(text)\n    print(perfect_matching(text))\n\n778817392288148379660189696000000\n\n\n\n\n26 Introduction to Random Strings\n\nimport math\n\ndef random_strings(seq, prob_seqs):\n    answer = \"\"\n    for prob in prob_seqs:\n        prob = float(prob)\n        gc_prob = prob/2\n        qa_prob = (1-prob)/2\n        multi = 1\n        for char in seq:\n            if char == \"G\" or char == \"C\":\n                multi *= gc_prob\n            else:\n                multi *= qa_prob\n        common_prob = round(math.log(multi, 10), 3)\n        answer += str(common_prob) + \" \"\n    return answer\n\n\nprint(random_strings(\"ACGATACAA\" , [0.129, 0.287, 0.423, 0.476, 0.641, 0.742, 0.783]))\n\n-5.737 -5.217 -5.263 -5.36 -5.958 -6.628 -7.009 \n\n\n\n\n27 Finding a Spliced Motif\n\ndef spliced_motif(s_seq, t_seq):\n    locations = \"\"\n    prev = 1\n    for i in t_seq:\n        pattern = re.compile(i)\n        m = pattern.search(s_seq)\n        locations += str(prev + m.start()) + \" \"\n        prev += m.start() + 1\n        s_seq = s_seq[m.start() + 1:]\n    \n    return locations\n\n\nwith open(\"../data/rosalind/rosalind_sseq.txt\", \"r\") as f:\n    text = f.read().split(\"&gt;\")[1:]\n    seq_1 = \"\".join(text[0].split(\"\\n\")[1:])\n    seq_2 = \"\".join(text[-1].split(\"\\n\")[1:])\n    print(spliced_motif(seq_1, seq_2))\n\n1 3 4 11 22 29 32 34 35 41 53 54 56 59 61 66 68 77 79 86 92 102 120 121 122 127 129 135 139 143 149 163 174 175 176 180 185 187 188 189 192 197 202 206 207 215 217 219 222 223 226 227 230 231 239 248 252 256 257 265 266 272 274 282 288 289 292 \n\n\n\n\n28 Transitions and Tranversions\n\ndef trans(seq_1, seq_2):\n    transition_r = 0\n    transversion_r = 0\n    nucleotides = {\"A\": \"purine\", \"G\" : \"purine\", \"T\" : \"pyrimidine\", \"C\" : \"pyrimidine\"}\n\n    for i, j in zip(seq_1, seq_2):\n        if nucleotides[i] == nucleotides[j] and i != j:\n            transition_r += 1\n        elif nucleotides[i] != nucleotides[j] and i != j:\n            transversion_r += 1\n\n    return transition_r/transversion_r\n\n\nwith open(\"../data/rosalind/rosalind_tran.txt\", \"r\") as file:\n    text = file.read().split(\"&gt;\")[1:]\n    seq_1 = \"\".join(text[0].split(\"\\n\")[1:])\n    seq_2 = \"\".join(text[-1].split(\"\\n\")[1:])\n    print(trans(seq_1, seq_2))\n\n1.797979797979798\n\n\n\n\n29 Completing a Tree\n\nfrom typing import List\ndef tree_build(num_nodes: int, adj_ls: List) -&gt; int:\n    present_nodes = 0\n    dis_graphs = []\n\n    ## Stop when you can not add another graphs to the current disgraphs\n    while len(adj_ls) &gt; 0:\n        dis_gr = adj_ls[0]\n        isAdded = True\n        if len(adj_ls) == 1:\n            dis_graphs.append(dis_gr)\n            break\n        elif len(adj_ls) &gt; 1:\n            adj_ls = adj_ls[1:]\n\n        while isAdded:\n            # print(dis_gr)\n            addition = 0\n            for i in range(len(adj_ls)):\n                ls = adj_ls[i]\n                intersectionality = list(set(dis_gr).intersection(ls))\n                if len(intersectionality) &gt; 0:\n                    dis_gr = list(set(dis_gr).union(set(ls)))\n                    adj_ls.pop(i)\n                    addition += 1\n                    break\n            if addition == 0:\n                isAdded = False\n                break\n        dis_graphs.append(dis_gr)\n\n    with open(\"../data/results/results_tree.txt\", \"w\") as file:\n        for each in dis_graphs:\n            file.write(str(each) + \"\\n\")\n    for graphs in dis_graphs:\n        present_nodes += len(graphs)\n    return len(dis_graphs) - 1 + (num_nodes - present_nodes)\n\n\nwith open(\"../data/rosalind/rosalind_tree.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    num_nodes = int(text[0])\n    adj_ls = [list(text.split(\" \")) for text in text[1:]]\n\n    print(tree_build(num_nodes, adj_ls))\n\n23\n\n\n\n\n30 Longest Increase Subsequence\n\nfrom typing import List\nimport copy\ndef subsequence(seq: List):\n    seq_length = len(seq)\n    increase = []\n    decrease = []\n\n    ## Add 1 to all arrays\n    for i in range(seq_length):\n        increase.append(1)\n        decrease.append(1)\n        seq[i] = int(seq[i])\n\n    ## Construct an array to store longest subsequence increasingly and decreasingly\n    for i in range(1, seq_length):\n        for j in range(i):\n            if seq[j] &gt; seq[i] and increase[i] &gt;= increase[j]:\n                increase[i] = increase[j] + 1\n    reverse_seq = seq\n    for i in range(1, seq_length):\n        for j in range(i):\n            if reverse_seq[i] &lt; reverse_seq[j] and decrease[i] &lt;= decrease[j]:\n                decrease[i] = decrease[j] + 1\n    ## Iterate through the array to find the maximum value of sequence\n    max_seq = 0\n    index_seq = 0\n    max_reverse_seq = 0\n    index_reverse_seq = 0\n    for i in range(seq_length):\n        if increase[i] &gt; max_seq:\n            max_seq = increase[i]\n            index_seq = i\n        if decrease[i] &gt; max_reverse_seq:\n            max_reverse_seq = decrease[i]\n            index_reverse_seq = i\n\n    ## Backtracking from the maximum value max, if meets max-1, add to list array[max-1]\n    ## and assign max = max - 1, continue to track from backward \n    longest_increase_seq = [seq[index_seq]]\n    longest_decrease_seq = [reverse_seq[index_reverse_seq]]\n\n    for i in range(index_seq - 1, -1, -1):\n        if max_seq == -1:\n            break\n        if increase[i] == max_seq - 1 and longest_increase_seq[-1] &gt; seq[i]:\n            longest_increase_seq.append(seq[i])\n            max_seq = max_seq - 1\n\n    for i in range(index_reverse_seq - 1, -1, -1):\n        if max_reverse_seq == -1:\n            break\n        if decrease[i] == max_reverse_seq - 1 and longest_decrease_seq[-1] &gt; reverse_seq[i]:\n            longest_decrease_seq.append(reverse_seq[i])\n            max_reverse_seq = max_reverse_seq - 1\n    with open(\"../data/results/results_lgis.txt\", \"w\") as f:\n        inc = \"\"\n        dec = \"\"\n        for item in longest_increase_seq[::-1]:\n            inc += str(item) + \" \"\n        for item in longest_decrease_seq[::-1]:\n            dec += str(item) + \" \"\n        f.write(inc)\n        f.write(\"\\n\")\n        f.write(dec)\n\n\nwith open(\"../data/rosalind/rosalind_lgis.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[1]\n    text = text.split(\" \")\n    # print(text)\n    subsequence(text)",
    "crumbs": [
      "Rosalind",
      "21-30"
    ]
  },
  {
    "objectID": "rosalind_markdowns/41_50.html",
    "href": "rosalind_markdowns/41_50.html",
    "title": "41-50",
    "section": "",
    "text": "41 Creating a Distance Matrix\n\nfrom utils import point_mutations\nimport numpy as np\ndef distance_matrix(seqs):\n    seq_length = len(seqs[0])\n    distance_matrix = np.zeros((len(seqs), len(seqs)))\n    for i, seq_1 in enumerate(seqs):\n        for j, seq_2 in enumerate(seqs):\n            if i == j:\n                distance = 0\n                distance_matrix[i][j] = 0.0\n            else:\n                distance = point_mutations(seq_1, seq_2)\n                distance_matrix[i][j] = round(distance/seq_length, 3)\n    return distance_matrix\n\n\nwith open(\"../data/rosalind/rosalind_pdst.txt\", \"r\") as file:\n    text = file.read().split(\"&gt;\")[1:]\n    seqs = []\n    for seq in text:\n        seq = seq.split(\"\\n\")[1:]\n        seq = \"\".join(seq)\n        seqs.append(seq)\n    print(distance_matrix(seqs))\n\n[[0.    0.481 0.587 0.458 0.489 0.46  0.298 0.326]\n [0.481 0.    0.582 0.632 0.458 0.617 0.582 0.324]\n [0.587 0.582 0.    0.675 0.304 0.666 0.635 0.471]\n [0.458 0.632 0.675 0.    0.625 0.479 0.303 0.553]\n [0.489 0.458 0.304 0.625 0.    0.615 0.581 0.289]\n [0.46  0.617 0.666 0.479 0.615 0.    0.323 0.567]\n [0.298 0.582 0.635 0.303 0.581 0.323 0.    0.478]\n [0.326 0.324 0.471 0.553 0.289 0.567 0.478 0.   ]]\n\n\n\n\n42 Reversal Distance\n\n\n43 Matching Random Motifs\n\ndef random_motifs(N, x, s):\n    P = 1.0\n    for char in s:\n        if char in 'AT':\n            P *= (1 - x)/2\n        elif char in 'GC':\n            P *= x/2\n    prob = 1 - (1 - P)**N\n    return prob\n\n\nprint(random_motifs(82568, 0.539812, \"AGCTTGCC\"))\n\n0.7632541926190596\n\n\n\n\n44 Counting Subsets\n\ndef subset_counts(n: int) -&gt; int:\n    return 2**(n) % 1000000\n\n\n\n45 Introduction to Alternative Splicing\n\n\n46 Edit Distance\n\n\n47 Expected Number of Restriction Sites\n\ndef expected_restriction(n, substr, arr):\n    str_len = len(substr)\n    n_select = n - str_len + 1\n    expected = []\n\n    for gc_content in arr:\n        GC_prob = gc_content / 2\n        AT_prob = 0.5 - GC_prob\n        prob = 1.0\n        for char in substr:\n            if char in \"GC\":\n                prob *= GC_prob\n            elif char in \"AT\":\n                prob *= AT_prob\n        expected.append(n_select*prob)\n\n    return expected\n\n\n\n48 Motzkin Numbers and RNA Secondary Structures\n\n\n49 Distances in Trees\n\n\n50 Interleaving two Motifs",
    "crumbs": [
      "Rosalind",
      "41-50"
    ]
  }
]