[
  {
    "objectID": "sorting/sort.html",
    "href": "sorting/sort.html",
    "title": "Insertion sorting",
    "section": "",
    "text": "I remember in my Computer Science II course, I got to learn about various sorting algorithms (merge sort, quicksort, selection sort…), each with its own time & space complexity.\nHere I implement sorting algorithm using insertion sort.\nBasically, the approach is that I’ll iterate through all the elements in the list, and for each element, I’ll compare with the ones before it until I reach a point where the current element is bigger than the previous.\n\nfrom typing import List\n\ndef insertion_sort(ls: List) -&gt; List:\n    \"\"\"\n        This function implements insertion sort.\n        -----\n        Parameters:\n        - ls (list): a list of unordered ints\n        -----\n        Returns:\n        - (list): the ascending ordered list\n    \"\"\"\n    new_ls = [ls[0]]\n    for i in range(1, len(ls)):\n        pivot = ls[i]\n        if pivot &gt;= new_ls[-1]:\n            new_ls.append(pivot)\n        else:\n            for j in range(len(new_ls) -1, -1, -1):\n                if pivot &gt;= new_ls[j]:\n                    new_ls.insert(j+1, pivot)\n                    break\n                elif j == 0:\n                    new_ls.insert(0, pivot)\n                elif pivot &lt; new_ls[j]:\n                    continue\n    return new_ls\n\nTest case of me trying on a random list of 10 positive ints:\n\na_list = [55, 17, 23, 1, 35, 89, 43, 4, 22, 11]\nprint(insertion_sort(a_list))\n\n[1, 4, 11, 17, 22, 23, 35, 43, 55, 89]\n\n\nNote\nTime complexity:\n\nWorst case: O(n2)\nBest case: O(n) (all elements are bigger so we only need to append to the lst)\n\nSpace complexity:\nO(1) -&gt; because the algorithm is in-place sorting, we need not extra memory",
    "crumbs": [
      "Sorting algorithms",
      "Insertion sorting"
    ]
  },
  {
    "objectID": "rosalind_markdowns/31_40.html",
    "href": "rosalind_markdowns/31_40.html",
    "title": "31-40",
    "section": "",
    "text": "31 Partial Permutations\n\nimport math\ndef count_partial_perm(n, k)-&gt;int:\n    \"\"\"\n        This function calculates the total number of partial permutations.\n        -----\n        Parameters:\n        - n (int): number of objects in total\n        - k (int): number of objects to draw on\n        -----\n        Returns:\n        - (int): the number of partial permutations\n    \"\"\"\n    total = math.factorial(n) / math.factorial(n-k)\n    return int(total % 1000000)\n\n\nprint(count_partial_perm(21, 7))\n\n51200\n\n\n\n\n32 Enumerating Oriented Gene Orderings\n\ndef enumerate_oriented_genes(n: int)-&gt;str:\n    \"\"\"\n        This function returns the total number of signed permutations of length \n        n, followed by a list of all such permutations\n        -----\n        Parameters:\n        - n (int): the length of permutations\n        -----\n        Returns:\n        - (str): the list of permutations with sign\n    \"\"\"\n    lst = []\n    for i in range(n):\n        lst.append(i + 1)\n    print(\"Before enumerating\", lst)\n    return enumerate_helper(lst, \"\", n)\n\ndef enumerate_helper(lst, seq, k):\n    ans = \"\"\n    ## base case, stops when k == 0\n    if k == 0:\n        return seq + \"\\n\"\n    \n    for i in range(len(lst)):\n        print(lst)\n        char = lst.pop(0)\n        seq_pos = seq + str(char) + \" \"\n        ans += enumerate_helper(lst, seq_pos, k - 1)\n        neg_char = char*-1\n        seq_neg = seq + str(neg_char) + \" \"\n        ans += enumerate_helper(lst, seq_neg, k - 1)\n        lst.append(char)\n    return ans\n\n\nprint(enumerate_oriented_genes(2))\n\nBefore enumerating [1, 2]\n[1, 2]\n[2]\n[2]\n[2, 1]\n[1]\n[1]\n1 2 \n1 -2 \n-1 2 \n-1 -2 \n2 1 \n2 -1 \n-2 1 \n-2 -1 \n\n\n\n\n\n33 Counting Subsets\n\ndef subset_counts(n: int) -&gt; int:\n    \"\"\"\n        This function returns the total number of subsets of {1, 2, …, n}\n        -----\n        Parameters:\n        - n (int): the length of original set\n        -----\n        Returns:\n        - (int): number of subsets\n    \"\"\"\n    return 2**(n) % 1000000\n\n\nprint(subset_counts(3))\n\n8\n\n\n\n\n34 Error Correction in Reads\n\nfrom utils import point_mutations, DNA_complementary\n\ndef error_corrections(seqs)-&gt;str:\n    \"\"\"\n        This function returns a list of all corrections in the form \n        \"[old read]-&gt;[new read]\". \n        -----\n        Parameters:\n        - seqs (List): a list of DNA sequences \n        -----\n        Returns:\n        - (str): the sequences before and after corrected\n    \"\"\"\n    seqs_dict = {}\n    correct_dict = {}\n    incorrect_dict = {}\n\n    for seq in seqs:\n        complementary = DNA_complementary(seq)\n        if seq in seqs_dict:\n            seqs_dict[seq] += 1\n        elif complementary in seqs_dict:\n            seqs_dict[complementary] += 1\n        elif seq not in seqs_dict:\n            seqs_dict[seq] = 1\n\n    for seq, value in seqs_dict.items():\n        if value &gt;= 2:\n            correct_dict[seq] = value\n        else:\n            incorrect_dict[seq] = value\n\n    ans = \"\"\n    for seq in incorrect_dict.keys():\n        for correct_seq in correct_dict.keys():\n            if point_mutations(seq, correct_seq) == 1:\n                ans += seq + \"-&gt;\" + correct_seq + \"\\n\"\n            elif point_mutations(DNA_complementary(seq), correct_seq) == 1:\n                ans += seq + \"-&gt;\" + correct_seq + \"\\n\"\n\n    return ans\n\n\nwith open(\"../data/rosalind/rosalind_corr.txt\", \"r\") as file:\n    text = file.read().split(\"&gt;\")[1:]\n    seqs = [\"\".join(seq.split(\"\\n\")[1:])for seq in text]\n    print(error_corrections(seqs))\n\nCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTGCCCC-&gt;CCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC\nCCCGAACCCTCAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA-&gt;CCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA\nTACCTAAACCTTACCCCGAACCCTAAGTGGCTGTGCTGAGTGACTGATCA-&gt;TACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA\nTAGGGATGGTTAGTTTTCACGACTAACCTAAACCTTACCCCGAACCCTAA-&gt;TAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAA\nACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAAC-&gt;ACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACC\nCTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA-&gt;GTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA\nGTGGGAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA-&gt;GTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA\nGGATGGTCAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTG-&gt;GGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTG\nTCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGTTTTGACCTGGCGA-&gt;TCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGA\nCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTTA-&gt;CCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA\nCCCCGAACCCTAAGTCGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTT-&gt;CCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTT\nTTTTTAGGGACGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC-&gt;TTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC\nAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGTGTGACTGATCAAGGCG-&gt;AAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG\nACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGATTGACTGATCAA-&gt;ACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAA\nTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACAGTCTAGGCGCCGCTT-&gt;TGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTT\nCTGATCAAGGCGCTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTG-&gt;CTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTG\nGCAGTGCTGAGTGACTGATCAAGTCGTTGACTTTAAGAAACGGTCTAGGC-&gt;GCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC\nTTTCACGACTTACCTAAACCTTACCCCGAACCTTAAGTGGCAGTGCTGAG-&gt;TTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAG\nACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTCAAGAAA-&gt;ACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAA\nCTGAGTGACTGATCAAGGCGTTGACTTCAAGAAACGGTCTAGGCGCCGCT-&gt;CTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT\nTGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAGCCCTAAGTGGCA-&gt;TGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCA\nCCCGAACCGTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA-&gt;CCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA\nAAGTGGCAGTGCTGAGTGACTGATCAAGGTGTTGACTTTAAGAAACGGTC-&gt;AAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC\nTTTCACGACTTACCTAAACCTTACCGCGAACCCTAAGTGGCAGTGCTGAG-&gt;TTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAG\nAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGCAA-&gt;AAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA\nAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCAGGCGAAA-&gt;AAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA\nGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCATTGACC-&gt;GACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACC\nACACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG-&gt;AAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG\nCAGTGCTGAGTGACTGGTCAAGGCGTTGACTTTAAGAAACGGTCTAGGCG-&gt;CAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCG\nAAACCTTAGCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG-&gt;AAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG\nGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGCTCTAGGC-&gt;GCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC\nTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGACTAGGCGCCG-&gt;TGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCG\nTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAATGACTGATCA-&gt;TACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA\nTGACTCATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAC-&gt;TGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAC\nGGATGGTTAATTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTG-&gt;GGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTG\nACGACTTACCTAAACCTTACCCCGAGCCCTAAGTGGCAGTGCTGAGTGAC-&gt;ACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC\nACTTACCTAAACGTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGA-&gt;ACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGA\nAGTGCTGAGTGAGTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC-&gt;AGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC\nCACGACTTACCTAAACCTGACCCCGAACCCTAAGTGGCAGTGCTGAGTGA-&gt;CACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGA\nAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCCCTTTG-&gt;AGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG\nTTTTCACGGCTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA-&gt;TTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA\nAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTGG-&gt;AGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG\nTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGCCGCCGCTTTGAC-&gt;TGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAC\nCCTAAGTGGCAGTGCTGAGTGACTGAGCAAGGCGTTGACTTTAAGAAACG-&gt;CCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACG\nAGTGCAGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC-&gt;AGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC\nCCCTATTTTATAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCC-&gt;CCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCC\nTTTAGGGATGGTTAATTTTCACGACTTACCTAAACCTTACCCCGAACCCT-&gt;TTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCT\nTTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCGCGAAC-&gt;TTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAAC\nGCTGAGTGACTGAACAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC-&gt;GCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC\nTTAGGGATGGTTAGTTTTCACGATTTACCTAAACCTTACCCCGAACCCTA-&gt;TTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA\nGCTGAGTGACTAATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC-&gt;GCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC\nAACCTTACCCCCAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT-&gt;AACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT\nCCGAACCCTAAGTGGCAGTGCTGAATGACTGATCAAGGCGTTGACTTTAA-&gt;CCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA\nCGTTGACTTTAAGGAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGGA-&gt;CGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGGA\nGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAAAGGTCTA-&gt;GTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA\nCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGCCAGTGCTGAGTGA-&gt;CACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGA\nATCAAGGCGTTGACTTTAAGAAACCGTCTAGGCGCCGCTTTGACCTGGCG-&gt;ATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG\nACGACTTACCTAAACCTTACTCCGAACCCTAAGTGGCAGTGCTGAGTGAC-&gt;ACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC\nATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGATCTGGCG-&gt;ATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG\nAGTTTTCTCGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCT-&gt;AGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCT\nTAGTTTTCACGACTTACCAAAACCTTACCCCGAACCCTAAGTGGCAGTGC-&gt;TAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGC\nTTTCGCGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAG-&gt;TTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAG\nTTTAGGGATGGTTAGATTTCACGACTTACCTAAACCTTACCCCGAACCCT-&gt;TTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCT\nGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAATTG-&gt;GGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTG\nAATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG-&gt;GATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG\nAGGGAGGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAG-&gt;AGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAG\nACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTATAAGAAA-&gt;ACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAA\nCCTATTTTTTAGGGATGGTTAGTTTTCAGGACTTACCTAAACCTTACCCC-&gt;CCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC\nACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTGTGACCT-&gt;ACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCT\nACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCACTTTGACCT-&gt;ACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCT\nAAACCCTATTTTTTAGGGATGGATAGTTTTCACGACTTACCTAAACCTTA-&gt;AAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA\nTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGAGCTGAGT-&gt;TTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGT\nCCTATTTTTTATGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC-&gt;CCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC\nATACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA-&gt;AAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA\nCCCCGAACCCTAAGTGGCAGTGCTGTGTGACTGATCAAGGCGTTGACTTT-&gt;CCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTT\nCTATTTTTTAGGGATGGTTAGCTTTCACGACTTACCTAAACCTTACCCCG-&gt;CTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCG\nTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACTTTACCCCGAACC-&gt;TTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC\nAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCAGCTTTGACCTGGCGAAA-&gt;AAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA\nCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGGCTTTA-&gt;CCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA\nGTTTTCACGACTTACCTAAACCTGACCCCGAACCCTAAGTGGCAGTGCTG-&gt;GTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTG\nGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAAC-&gt;GACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACC\nCAGTGCTGAGTGAATGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCG-&gt;CAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCG\nTTTTAGGGATGGTTAGTTCTCACGACTTACCTAAACCTTACCCCGAACCC-&gt;TTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCC\nTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACATTACCCCGAACCCT-&gt;TTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCT\nCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAACCCTTACCCCG-&gt;CTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCG\nTTTTCACGACTTACCTATACCTTACCCCGAACCCTAAGTGGCAGTGCTGA-&gt;TTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA\nTAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTA-&gt;TAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT\nGCGTTGATTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGG-&gt;GCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGG\nTGATCAAGGCGTGGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG-&gt;TGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG\nTCAAGGCGTTGACTTTAAGAAGCGGTCTAGGCGCCGCTTTGACCTGGCGA-&gt;TCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGA\nAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGGCTTTAAGAA-&gt;AACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAA\nGTGACTGAGCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA-&gt;GTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA\nACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCCTTGACTT-&gt;ACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTT\nCCTAAACCTTACCCCGAACCCTAATTGGCAGTGCTGAGTGACTGATCAAG-&gt;CCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAG\nAGTGACTGATCAAGGCGTTGACTTCAAGAAACGGTCTAGGCGCCGCTTTG-&gt;AGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG\nTTATCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA-&gt;TTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA\nCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGG-&gt;CTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA\nAGGGATGGTTAGTTTTGACGACTTACCTAAACCTTACCCCGAACCCTAAG-&gt;AGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAG\nATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGTG-&gt;ATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG\nCTTACCCCGCACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA-&gt;CTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA\nAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTATG-&gt;AGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAG\nTACGCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACT-&gt;TACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACT\nACTTACCTAAACCTTACCGCGAACCCTAAGTGGCAGTGCTGAGTGACTGA-&gt;ACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGA\nCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGAA-&gt;CGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGGA\nTTTTGAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC-&gt;TTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC\nCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATTAAGGCGTTGACTTTAA-&gt;CCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA\nTTAGGGATGGTTAGTTTTCACGACTTACATAAACCTTACCCCGAACCCTA-&gt;TTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA\nAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTCAACCTTAC-&gt;AACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC\nTAAACCTTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT-&gt;TAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT\nACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTAACTGATCAAGGCGTT-&gt;ACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTT\nGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGATCTAGGCGCCGC-&gt;GCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC\nTGTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC-&gt;TTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC\nGCAGTGCTGACTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC-&gt;GCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC\nTCAAGGCGTTGACGTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGA-&gt;TCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGA\nCCTATTTTTTAGGGATGGTTATTTTTCACGACTTACCTAAACCTTACCCC-&gt;CCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC\nTGATCAAGGCGCTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG-&gt;TGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG\nTTACCTAAACCTTACCCCTAACCCTAAGTGGCAGTGCTGAGTGACTGATC-&gt;TTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATC\nCACGACTTACCTAATCCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGA-&gt;CACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGA\nCGAACCCTAAGTGGCAGTGCTGAGTGACTGACCAAGGCGTTGACTTTAAG-&gt;CGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAG\nCTGAGTGACTGTTCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT-&gt;CTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT\nGCAGTGCTGAGTGACTGATCAAGGCGGTGACTTTAAGAAACGGTCTAGGC-&gt;GCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC\nGAGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA-&gt;GTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA\nCCTAAACCTTACCCCGAACCCTAAGTGCCAGTGCTGAGTGACTGATCAAG-&gt;CCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAG\nAGTGGCAGTGCTGAGTGACCGATCAAGGCGTTGACTTTAAGAAACGGTCT-&gt;AGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCT\nGTTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC-&gt;GCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC\nCACGACTTACCTAAACCTTACGCCGAACCCTAAGTGGCAGTGCTGAGTGA-&gt;CACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGA\nACCTAACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTT-&gt;ACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTT\nCAACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACT-&gt;CGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACT\nCTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGAGCCGCTTTGACCTG-&gt;CTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTG\nAAACCCTTTTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA-&gt;AAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA\nTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAAGC-&gt;TTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC\nATCAAGGCGTTGACTTTAAGCAACGGTCTAGGCGCCGCTTTGACCTGGCG-&gt;ATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG\nTTTTTACGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC-&gt;TTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC\nGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCAAGGCGCC-&gt;GTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCC\nTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGGCTTTAAGAAACGGT-&gt;TAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGT\nGATGGTTAGTTTTCACGACTTATCTAAACCTTACCCCGAACCCTAAGTGG-&gt;GATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG\nTGACTGATAAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAC-&gt;TGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAC\nGTTTTCACGACTTACCTAAACCTTAGCCCGAACCCTAAGTGGCAGTGCTG-&gt;GTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTG\nTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATAAAGGCGTTGAC-&gt;TTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC\nCCCGAACCCTAAGTGGCAGTGCTGAGTGCCTGATCAAGGCGTTGACTTTA-&gt;CCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA\nTCAAGGGGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGA-&gt;TCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGA\nGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTATGTGGCAG-&gt;GGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAG\nTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCTAGGCGTTGACT-&gt;TACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACT\nTTACCCCGAACCCTAAGTGGCAGTGCTGATTGACTGATCAAGGCGTTGAC-&gt;TTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC\nGATGGTTAGTTTTCACGACTTACCTAAACCTTATCCCGAACCCTAAGTGG-&gt;GATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG\nCTGAGTGACTGATCAAGGCGTTGACGTTAAGAAACGGTCTAGGCGCCGCT-&gt;CTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT\nTGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAATGGCA-&gt;TGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCA\nAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGAG-&gt;AAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG\nTAGCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACT-&gt;TACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACT\nAAGTGGCAGTGCTGAGTGACTGATCAAGGCCTTGACTTTAAGAAACGGTC-&gt;AAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC\nATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTTGC-&gt;ATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGC\nCGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGACTGACT-&gt;CGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACT\nGTGACTGATCAAGGCGTTGACTTTGAGAAACGGTCTAGGCGCCGCTTTGA-&gt;GTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA\nTTTTTACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA-&gt;TTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA\nCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATGAAGGCGTTGACTTTAA-&gt;CCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA\nGTTAGTTTTCACGACTTACCTAAACCCTACCCCGAACCCTAAGTGGCAGT-&gt;GTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGT\nACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTAA-&gt;ACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGA\nATCAAGGCGTTGACTTTAAGAAACGGTCCAGGCGCCGCTTTGACCTGGCG-&gt;ATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG\nTAAACCTTACCCCGAACCCTAAGTGGCAGTGCAGAGTGACTGATCAAGGC-&gt;TAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGC\nTAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC-&gt;AAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC\nCTTACCTAAACCTTACCCCGAACTCTAAGTGGCAGTGCTGAGTGACTGAT-&gt;CTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGAT\nAAACCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC-&gt;AACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC\nGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGAAGTGCTG-&gt;GTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTG\nTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAATGATCA-&gt;TACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA\nAAAACTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG-&gt;AAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG\nCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGATTTTA-&gt;CCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA\nAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTC-&gt;AAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA\nATCAAGGCGTTGACTTTAAGAAACGGTTTAGGCGCCGCTTTGACCTGGCG-&gt;ATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG\nTACCTAAACCTTACCACGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA-&gt;TACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA\nTAAACCCTATTTTTTCGGGATGGTTAGTTTTCACGACTTACCTAAACCTT-&gt;TAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT\nTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAACAAACGGTCTAG-&gt;TGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAG\nTTCAGGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGT-&gt;TTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGT\nGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCGTTGACCTGGCGAAACGG-&gt;GCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGG\nCCTTACCCCGAACCCTAAGTGGCAGTGCTAAGTGACTGATCAAGGCGTTG-&gt;CCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTG\nTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTCGCAGTGCTGA-&gt;TTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA\nAGTGGCAGTGCTGAGTGACTGATCAACGCGTTGACTTTAAGAAACGGTCT-&gt;AGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCT\nTTCACGACTTACCTAAACCTTACCCCGAACCTTAAGTGGCAGTGCTGAGT-&gt;TTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGT\nAACCTTACCCCGAACCCTAAGTGGCAGTGCTGTGTGACTGATCAAGGCGT-&gt;AACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT\nACTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC-&gt;GCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC\nAGGCCTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAAC-&gt;AGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAAC\nCTTACCCCGAACCCTAAGTGGTAGTGCTGAGTGACTGATCAAGGCGTTGA-&gt;CTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA\nATTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCT-&gt;AGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCT\nACTGATCAAGGCTTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCT-&gt;ACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCT\nAAACCTTACCCCTAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG-&gt;AAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG\nTACCCCGAACCCTAAGTGGCAGTGCAGAGTGACTGATCAAGGCGTTGACT-&gt;TACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACT\nACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTTCCTAAACCTTACC-&gt;ACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACC\nTTACCGCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC-&gt;TTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC\nGTGACTGATCAAGGGGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA-&gt;GTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA\nGTGACTGATCAAGGCGTTGACTTTAAGAAGCGGTCTAGGCGCCGCTTTGA-&gt;GTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA\nACGACTTACCTAAACCGTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC-&gt;ACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC\nAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTATG-&gt;AGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG\nAGTGACTGATCAAGGCGTTGATTTTAAGAAACGGTCTAGGCGCCGCTTTG-&gt;AGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG\nCCCGAACCCTAAGTGGCAGTGGTGAGTGACTGATCAAGGCGTTGACTTTA-&gt;CCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA\nGATCAAGGCGTTGACTTTGAGAAACGGTCTAGGCGCCGCTTTGACCTGGC-&gt;GATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGC\nCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTCGACCTGGCGAAACGGA-&gt;CGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGGA\nACCCTATTTTTTAGGGTTGGTTAGTTTTCACGACTTACCTAAACCTTACC-&gt;ACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACC\nGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGATG-&gt;GTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTG\nCTTACCCTGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA-&gt;CTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA\nAGTGACTGATCACGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG-&gt;AGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG\nCCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCCAGGCGTTGACTTT-&gt;CCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTT\nAGTGACTGATCAAGGAGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG-&gt;AGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG\nCTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCAGAGTGACTGAT-&gt;CTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGAT\nCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTAGCGAA-&gt;CAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAA\nTGATCAAGGCGTTGACTTAAAGAAACGGTCTAGGCGCCGCTTTGACCTGG-&gt;TGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG\nCCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTAGACTTTAAGAAAC-&gt;CCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAAC\nGTTAGTTTTCACGACTTACCTAAACCTTAACCCGAACCCTAAGTGGCAGT-&gt;GTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGT\nTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCGAA-&gt;TAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAA\nGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTGT-&gt;GAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTT\nAACCCTAAGTGGCAGTGCTGAGTGACTGATCTAGGCGTTGACTTTAAGAA-&gt;AACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAA\nAGTTTCCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCT-&gt;AGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCT\nCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCCCCGCT-&gt;CTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT\nACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGAACAA-&gt;ACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAA\nACGACTTACCTAAACCTTACCCAGAACCCTAAGTGGCAGTGCTGAGTGAC-&gt;ACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC\nGATCAAGGCGTTGACTTTAAAAAACGGTCTAGGCGCCGCTTTGACCTGGC-&gt;GATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGC\nTATTTTTTAGGGATGGTTAGTTTTCACGACTTTCCTAAACCTTACCCCGA-&gt;TATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGA\nTTTTCACGACTTACCTAAACCTTACCCCGAACCCTATGTGGCAGTGCTGA-&gt;TTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA\nTCACGACTTACCTAAACCCTACCCCGAACCCTAAGTGGCAGTGCTGAGTG-&gt;TCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTG\nACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTAACCT-&gt;ACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCT\nCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACGTTACCCCG-&gt;CTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCG\nGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTTTAGGCGCCGCTTT-&gt;GAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTT\nGTGGCAGTGCCGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA-&gt;GTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA\nCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTCCCCCG-&gt;CTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCG\nGACTTGCCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTG-&gt;GACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTG\nAGTGCTGAGTGACTGATCAAGGCCTTGACTTTAAGAAACGGTCTAGGCGC-&gt;AGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC\nGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCCCTTT-&gt;GAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTT\nTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCCGAGTGACTGATCA-&gt;TACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA\nCCTACACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAG-&gt;CCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAG\nTAGTTTTCACGACTGACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGC-&gt;TAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGC\nTGAGTGACTGATCAAGGCGTTAACTTTAAGAAACGGTCTAGGCGCCGCTT-&gt;TGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTT\nCTGAGTGACTGATCAAGGCGTTGACTTTTAGAAACGGTCTAGGCGCCGCT-&gt;CTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT\nTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAATGGTCTAG-&gt;TGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAG\nGGTTAGTTTTCACGACTTTCCTAAACCTTACCCCGAACCCTAAGTGGCAG-&gt;GGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAG\nTTAGGGATGGTTAGTTTTGACGACTTACCTAAACCTTACCCCGAACCCTA-&gt;TTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA\nCTATTTTTTAGGGATCGTTAGTTTTCACGACTTACCTAAACCTTACCCCG-&gt;CTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCG\nAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCCAAGTGGCAGTGCT-&gt;AGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCT\nGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTAACC-&gt;GACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACC\nTAGTTTTCACGACTTACCTAAAGCTTACCCCGAACCCTAAGTGGCAGTGC-&gt;TAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGC\nACCTTACCCCGAACCCTAAGTGGCAGGGCTGAGTGACTGATCAAGGCGTT-&gt;ACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTT\nACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTAAGTGAC-&gt;ACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC\nCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCGG-&gt;CTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCG\nACTTTCCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGA-&gt;ACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGA\nGAGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA-&gt;GTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA\nTCAAGGAGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGA-&gt;TCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGA\nGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGACTAGGCGCCGCTTT-&gt;GAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTT\nCAAGGTGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAA-&gt;CAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAA\nCCTATTGTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC-&gt;CCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC\nATTTTTTAGGGATGATTAGTTTTCACGACTTACCTAAACCTTACCCCGAA-&gt;ATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAA\nATCAAAGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG-&gt;ATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG\nGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCGG-&gt;GTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTG\nGTGACTGATCAAGGCGTTAACTTTAAGAAACGGTCTAGGCGCCGCTTTGA-&gt;GTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA\nGAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGC-&gt;TAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGC\nCCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAATC-&gt;CCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAAC\nACCTTACCCCGAACCCTACGTGGCAGTGCTGAGTGACTGATCAAGGCGTT-&gt;ACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTT\nCCCGAACCCTAAGTGGCAGTGCGGAGTGACTGATCAAGGCGTTGACTTTA-&gt;CCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA\nTTTTAGGGACGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCC-&gt;TTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCC\nCCTACTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC-&gt;CCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC\nTAAACCCTATTTTTTAGGGATGTTTAGTTTTCACGACTTACCTAAACCTT-&gt;TAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT\nTAAACCCTATTTTTTAGGTATGGTTAGTTTTCACGACTTACCTAAACCTT-&gt;TAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT\nGTTAGTTTTCACGACGTACCTAAACCTTACCCCGAACCCTAAGTGGCAGT-&gt;GTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGT\nGTGACTGATTAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA-&gt;GTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA\nGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCTCCGCTTT-&gt;GAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTT\nCTGAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGG-&gt;CTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGG\nAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAGCTGGCGAAA-&gt;AAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA\nTGGTTAGTTTTCACGACTTTCCTAAACCTTACCCCGAACCCTAAGTGGCA-&gt;TGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCA\nCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACCGTCTAGGCG-&gt;CAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCG\nGATGGTTAGTTTTCACGACTTACCTAAAGCTTACCCCGAACCCTAAGTGG-&gt;GATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG\nTAAAACCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT-&gt;TAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT\nTTTTCACGACTTACCTAAACCCTACCCCGAACCCTAAGTGGCAGTGCTGA-&gt;TTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA\nCGAACCCTAAGTGCCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAG-&gt;CGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAG\nCTGAGTGGCTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT-&gt;CTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT\nCTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTATGACCTG-&gt;CTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTG\nGGGATGGTTAGTTTTCACGACTTACCGAAACCTTACCCCGAACCCTAAGT-&gt;GGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGT\nAAACCCTATTTTTTAGGGATGGTGAGTTTTCACGACTTACCTAAACCTTA-&gt;AAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA\nAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCAT-&gt;AACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT\nCCCTAAGTGGCAGTGCTGAGTGACTGATCAGGGCGTTGACTTTAAGAAAC-&gt;CCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAAC\nGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTCAGAAACGGTCTAGGC-&gt;GCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC\nCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCAAGGCG-&gt;CAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCG\nATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAGCCCGAA-&gt;ATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAA\nCCTTACCCCGACCCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTG-&gt;CCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTG\nTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGCCCTGG-&gt;TGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG\nTTTAGGGATGGTTAGTTTTCACGACTTACCTAATCCTTACCCCGAACCCT-&gt;TTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCT\nTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCCTTGACCTGG-&gt;TGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG\nTTACCCCGAACGCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC-&gt;TTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC\nTACCTAAACATTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA-&gt;TACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA\nAACCTTACCCCGAACCCCAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT-&gt;AACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT\nGACTGATCAAGGCGTTGACTTTAAGAAACTGTCTAGGCGCCGCTTTGACC-&gt;GACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACC\nTTAGTTTTCACGCCTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTG-&gt;TTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTG\nTAGGGAAGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAA-&gt;TAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAA\nCACGACTTACCTAAACCTTACCCCGAACCCTTAGTGGCAGTGCTGAGTGA-&gt;CACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGA\nTGGTTAGTTTTCACGACTTACCTAAAACTTACCCCGAACCCTAAGTGGCA-&gt;TGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCA\nTTACCCTGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC-&gt;TTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC\nAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTTCCTAAACCTTA-&gt;AAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA\nGAAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCT-&gt;GTAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCT\nAGTGCTGAGCGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC-&gt;AGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC\nTTTTTAGGGATGGTTAGTTTTCACGACTTACCTATACCTTACCCCGAACC-&gt;TTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC\nGATGGTTAGTTTTCTCGACTTACCTAAACCTTACCCCGAACCCTAAGTGG-&gt;GATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG\nGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACA-&gt;GGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACG\nGAGTGACTGATCACGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTT-&gt;GAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTT\nAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCGCGAACCCTAAG-&gt;AGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAG\nAGGGATGGTTAGTTTTCACGACTTACCTAAAACTTACCCCGAACCCTAAG-&gt;AGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAG\nGTTTTCACGACTTACCAAAACCTTACCCCGAACCCTAAGTGGCAGTGCTG-&gt;GTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTG\nCGACTTACCTAAACCTTACCCCGAACCCTAAGTGGAAGTGCTGAGTGACT-&gt;CGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACT\nCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAGCGGA-&gt;CGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGGA\nACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTCTGACCT-&gt;ACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCT\nGACTGATCAAGGCGTTGACTTTAATAAACGGTCTAGGCGCCGCTTTGACC-&gt;GACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACC\nTTAGGGATGGTTAGTTTTCACGACATACCTAAACCTTACCCCGAACCCTA-&gt;TTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA\nCCTATTTTTTAGGGATGGTTAGTTTTCACTACTTACCTAAACCTTACCCC-&gt;CCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC\nTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGTCT-&gt;TACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACT\nTGCTGAGTGGCTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCG-&gt;TGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCG\nAAGTGGCAGTGCTGAGTGACTGATTAAGGCGTTGACTTTAAGAAACGGTC-&gt;AAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC\nTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTGGACTTTAAGAAACGGT-&gt;TAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGT\nGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTACGA-&gt;GAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGA\nAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCCC-&gt;AGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC\nACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACAT-&gt;ACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTT\nACCCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC-&gt;AACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC\nAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTAACTAAACCTTAC-&gt;AACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC\nCTAAGTGGCGGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGG-&gt;CTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGG\nCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCAAA-&gt;CAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAA\nTGGTTAGTTTTCACGACCTACCTAAACCTTACCCCGAACCCTAAGTGGCA-&gt;TGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCA\nGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTAACCTGGCGAAACGG-&gt;GCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGG\nAGTGGCAGTGCTGAGTGACTGATAAAGGCGTTGACTTTAAGAAACGGTCT-&gt;AGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCT\nCCGAACCCTAAGTGACAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA-&gt;CCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA\nTTGGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA-&gt;TTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA\nAAACCATACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG-&gt;AAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG\nGCAGTGGTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC-&gt;GCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC\nAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCAAAACCTTAC-&gt;AACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC\nAACCCTATTTTTTAGGGATGGCTAGTTTTCACGACTTACCTAAACCTTAC-&gt;AACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC\nAAGGCGTTGACTTTAAGTAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA-&gt;AAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA\nACTGATCAACGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCT-&gt;ACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCT\nAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGTTTTGACCTGGCGAAA-&gt;AAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA\nCTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCACTTTGACCTG-&gt;CTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTG\nTGAGTGACTGATCAAGGCGTTTACTTTAAGAAACGGTCTAGGCGCCGCTT-&gt;TGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTT\nTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACGCTA-&gt;TTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA\nAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGCCTTTAAGAAACGGTCT-&gt;AGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCT\nGCAGTGCTGAGTGACTGATAAAGGCGTTGACTTTAAGAAACGGTCTAGGC-&gt;GCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC\nAGTGCCTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG-&gt;AGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTG\nTGAGTGACTGATCAAGGCGTTGACTTTAGGAAACGGTCTAGGCGCCGCTT-&gt;TGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTT\nTGAGTGACTGATCATGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTT-&gt;TGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTT\nAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGATACGGTC-&gt;AAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC\nCAGTGCTGAGTGACTGATCAAGGCGTTGATTTTAAGAAACGGTCTAGGCG-&gt;CAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCG\nCAAGGCGTGGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAA-&gt;CAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAA\nACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGCCTT-&gt;ACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTT\nGCTGAGTGACTGATCAAGGCGTTGACTGTAAGAAACGGTCTAGGCGCCGC-&gt;GCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGC\nTTTAGGGATGGTTAGTTTTCACGACTTAACTAAACCTTACCCCGAACCCT-&gt;TTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCT\nGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGGCTTTAAGA-&gt;GAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGA\nTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCAAACCC-&gt;TTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCC\nCCTAGGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACG-&gt;CCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACG\nTTCACGACTTACCTAAATCTTACCCCGAACCCTAAGTGGCAGTGCTGAGT-&gt;TTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGT\nGGGAGGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGT-&gt;GGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGT\nCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTAA-&gt;CTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA\nTTTTCACGACTTACCTAAACCTTACCTCGAACCCTAAGTGGCAGTGCTGA-&gt;TTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGA\nCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAGGGCGTTGACTTTAA-&gt;CCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA\nTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCTAACCCTA-&gt;TTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA\nTGATTAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG-&gt;TGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGG\nTAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAGACCTT-&gt;TAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT\nATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAAACCTAAGTGGC-&gt;ATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGC\nGTTAGTTGTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGT-&gt;GTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGT\nTATGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGT-&gt;TAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGT\nGATGGTTAGTTTTCACGACTTTCCTAAACCTTACCCCGAACCCTAAGTGG-&gt;GATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG\nGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGCAACGG-&gt;GCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGG\nCTATTTTTTAGGGATGGTCAGTTTTCACGACTTACCTAAACCTTACCCCG-&gt;CTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCG\nTTTAGGGATGCTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCT-&gt;TTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCT\nAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCCT-&gt;AACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT\nCACGACTTACCTAAAGCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGA-&gt;CACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGA\nTTAGGGGTGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA-&gt;TTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTA\nTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTAGAC-&gt;TGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAC\nAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACGGATCAAGGCG-&gt;AAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCG\nCCTAAACCTTACCCCGAACCCTATGTGGCAGTGCTGAGTGACTGATCAAG-&gt;CCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAG\nACTTACCTAAACCTTACCCCGAACCCTAAGTGGCACTGCTGAGTGACTGA-&gt;ACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGA\nGGATGGTTAGTTTTCACGACTTACTTAAACCTTACCCCGAACCCTAAGTG-&gt;GGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTG\nTAAACCCTATCTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT-&gt;TAAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTT\nGATGGTTATTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG-&gt;GATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGG\nTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGAGC-&gt;TAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGC\nAAGGGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC-&gt;AAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC\nCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTACGCG-&gt;CAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCG\nACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCGA-&gt;ACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAA\nCCTAACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTG-&gt;CCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTG\nAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGCTCAAGGCGT-&gt;AACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT\nACCCTAAGTGGCAGTCCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAA-&gt;ACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAA\nACGACTTACCTAAACCTTATCCCGAACCCTAAGTGGCAGTGCTGAGTGAC-&gt;ACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC\nAAGGCGTTGACTTTAAGAAACGCTCTAGGCGCCGCTTTGACCTGGCGAAA-&gt;AAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA\nCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACTTAAACCTTACCCC-&gt;CCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCC\nCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAAGCTTACCCCG-&gt;CTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCG\nAAGTGGCAGTGCTGAGTGACTGATCAATGCGTTGACTTTAAGAAACGGTC-&gt;AAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC\nAGTTTTCACGACTTACCCAAACCTTACCCCGAACCCTAAGTGGCAGTGCT-&gt;AGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCT\nGTTAGTTTTCACGACTTACCTAAAGCTTACCCCGAACCCTAAGTGGCAGT-&gt;GTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGT\nTAGGGATGGTTAGTTTTCACGAATTACCTAAACCTTACCCCGAACCCTAA-&gt;TAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAA\nCCCCGAACCCTAAGTGGCAGGGCTGAGTGACTGATCAAGGCGTTGACTTT-&gt;CCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTT\nAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAAGCGT-&gt;AACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGT\nCTAAGTGGCCGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGG-&gt;CTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGG\nACCCCGAACCCTAAGTGGCAATGCTGAGTGACTGATCAAGGCGTTGACTT-&gt;ACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTT\nTAGGGATGGTAAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAA-&gt;TAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAA\nAACCCTAAGTGGCAGTGCTGAGTGACTGAGCAAGGCGTTGACTTTAAGAA-&gt;AACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAA\nTACCTAAACCTTACCCCGAATCCTAAGTGGCAGTGCTGAGTGACTGATCA-&gt;TACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA\nGAGTGACTGATCAAGGCGTTGACGTTAAGAAACGGTCTAGGCGCCGCTTT-&gt;GAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTT\nAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGTGAAA-&gt;AAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAA\nAACCCTAATTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC-&gt;AACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTAC\nCCTAAACCTTACCCCGAACCCAAAGTGGCAGTGCTGAGTGACTGATCAAG-&gt;CCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAG\nTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACTCCGAACCC-&gt;TTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCC\nTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGCTCA-&gt;TACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCA\nTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCCTACCCCGA-&gt;TATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGA\nGTTTTCACGACTTACCTAAACCTTACCTCGAACCCTAAGTGGCAGTGCTG-&gt;GTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTG\nGTGACTGATCAAGGCGTAGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA-&gt;GTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGA\nATCAAGGCGTTGACTTTAAGAAGCGGTCTAGGCGCCGCTTTGACCTGGCG-&gt;ATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCG\nGGCAGTGCTGAGTCACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGG-&gt;GGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGG\nTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATGAAGGCGTTGAC-&gt;TTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGAC\nGCGGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC-&gt;GCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGC\nACCCCGAACCATAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTT-&gt;ACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTT\nATGGTTAGTTTTCACGACTAACCTAAACCTTACCCCGAACCCTAAGTGGC-&gt;ATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGC\nCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTAACTTTA-&gt;CCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTA\nAGTTTTCACGACTTACCAAAACCTTACCCCGAACCCTAAGTGGCAGTGCT-&gt;AGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCT\nTAGTTTTCACGACTTACCTAAACGTTACCCCGAACCCTAAGTGGCAGTGC-&gt;TAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGC\nACTTACCTAAACCTTACCCCGAACCCTAAATGGCAGTGCTGAGTGACTGA-&gt;ACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGA\nTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAT-&gt;TGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAC\nAGTGCTGAGTGACTGATCAAGGCGTTGACCTTAAGAAACGGTCTAGGCGC-&gt;AGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGC\nACGACTTACCTAAAACTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC-&gt;ACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGAC\nAAGTGGCAGTGCTGAGTGACTGATCAAGGCTTTGACTTTAAGAAACGGTC-&gt;AAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTC\nCCTAAGTGGCAGTGCGGAGTGACTGATCAAGGCGTTGACTTTAAGAAACG-&gt;CCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACG\nCCGAAGCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA-&gt;CCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAA\nCTTACCTAAACCTTACCCCGAACACTAAGTGGCAGTGCTGAGTGACTGAT-&gt;CTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGAT\nAAACCCTGTTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA-&gt;AAACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTA\nTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGATCCC-&gt;TTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCC\nGCGTAGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGG-&gt;GCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGG\nCTTAACCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA-&gt;CTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTGA\nCTGAGTGACTGATCAAGGTGTTGACTTTAAGAAACGGTCTAGGCGCCGCT-&gt;CTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCT\nGCGTTGACTTTAAGAAACGGTCTAGGCGCTGCTTTGACCTGGCGAAACGG-&gt;GCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGACCTGGCGAAACGG\nACCCTATTTTTTAGGCATGGTTAGTTTTCACGACTTACCTAAACCTTACC-&gt;ACCCTATTTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACC\nTTTCACGACTTACCTACACCTTACCCCGAACCCTAAGTGGCAGTGCTGAG-&gt;TTTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAG\nCGACTTACCTCAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACT-&gt;CGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACT\nTTTTTAGAGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC-&gt;TTTTTAGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACC\nAGGGATGGTTAGTTTTCACGACTTACCTAAACCTAACCCCGAACCCTAAG-&gt;AGGGATGGTTAGTTTTCACGACTTACCTAAACCTTACCCCGAACCCTAAG\nTGAGTGACTGATCAAGGCGTTGACTTTAAGGAACGGTCTAGGCGCCGCTT-&gt;TGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTT\nGTGGCAGTGATGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA-&gt;GTGGCAGTGCTGAGTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTA\nTGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCGTTGAC-&gt;TGACTGATCAAGGCGTTGACTTTAAGAAACGGTCTAGGCGCCGCTTTGAC\nCCTTACCCCGAAGCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTG-&gt;CCTTACCCCGAACCCTAAGTGGCAGTGCTGAGTGACTGATCAAGGCGTTG\nTTCACGACTTACCTAAACCTTGCCCCGAACCCTAAGTGGCAGTGCTGAGT-&gt;TTCACGACTTACCTAAACCTTACCCCGAACCCTAAGTGGCAGTGCTGAGT\n\n\n\n\n\n35 Counting Phylogenetic Ancestors\n\ndef ancestors_count(n: int) -&gt; int:\n    \"\"\"\n        This function returns the number of internal nodes of any unrooted \n        binary tree having n leaves.\n        -----\n        Parameters\n        - n (int): the number of leaves in the binary tree\n        -----\n        Returns:\n        - (int): the number of internal nodes of the tree\n    \"\"\"\n    if n &gt;= 4:\n        return n // 2 + n % 2\n    else:\n        return n - 2\n\n\nprint(ancestors_count(8))\n\n4\n\n\n\n\n36 k-Mer Composition\n\nfrom utils import k_mers_enumerate\ndef k_mer_composition(seq_str)-&gt;str:\n    \"\"\"\n        This function returns all the 4-mer composition of s.\n        -----\n        Parameters:\n        - seq_str (str): the DNA string\n        -----\n        Returns:\n        - (str): all the 4-mer composition of the string\n    \"\"\"\n    k_mers = k_mers_enumerate([\"A\", \"C\", \"G\", \"T\"], 4)\n    k_mers = k_mers.split(\"\\n\")[:-1]\n    print(k_mers)\n    dict = {}\n    for i in range(len(seq_str)-3):\n        seq = seq_str[i:i+4]\n        if seq not in dict:\n            dict[seq] = 1\n        else:\n            dict[seq] += 1\n    ans = \"\"\n    for k_mer in k_mers:\n        if k_mer in dict:\n            ans += str(dict[k_mer]) + \" \"\n        else:\n            ans += str(0) + \" \"\n    return ans\n\n\nwith open(\"../data/rosalind/rosalind_kmer.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[1:]\n    seq = \"\".join(text)\n    print(k_mer_composition(seq))\n\n['AAAA', 'AAAC', 'AAAG', 'AAAT', 'AACA', 'AACC', 'AACG', 'AACT', 'AAGA', 'AAGC', 'AAGG', 'AAGT', 'AATA', 'AATC', 'AATG', 'AATT', 'ACAA', 'ACAC', 'ACAG', 'ACAT', 'ACCA', 'ACCC', 'ACCG', 'ACCT', 'ACGA', 'ACGC', 'ACGG', 'ACGT', 'ACTA', 'ACTC', 'ACTG', 'ACTT', 'AGAA', 'AGAC', 'AGAG', 'AGAT', 'AGCA', 'AGCC', 'AGCG', 'AGCT', 'AGGA', 'AGGC', 'AGGG', 'AGGT', 'AGTA', 'AGTC', 'AGTG', 'AGTT', 'ATAA', 'ATAC', 'ATAG', 'ATAT', 'ATCA', 'ATCC', 'ATCG', 'ATCT', 'ATGA', 'ATGC', 'ATGG', 'ATGT', 'ATTA', 'ATTC', 'ATTG', 'ATTT', 'CAAA', 'CAAC', 'CAAG', 'CAAT', 'CACA', 'CACC', 'CACG', 'CACT', 'CAGA', 'CAGC', 'CAGG', 'CAGT', 'CATA', 'CATC', 'CATG', 'CATT', 'CCAA', 'CCAC', 'CCAG', 'CCAT', 'CCCA', 'CCCC', 'CCCG', 'CCCT', 'CCGA', 'CCGC', 'CCGG', 'CCGT', 'CCTA', 'CCTC', 'CCTG', 'CCTT', 'CGAA', 'CGAC', 'CGAG', 'CGAT', 'CGCA', 'CGCC', 'CGCG', 'CGCT', 'CGGA', 'CGGC', 'CGGG', 'CGGT', 'CGTA', 'CGTC', 'CGTG', 'CGTT', 'CTAA', 'CTAC', 'CTAG', 'CTAT', 'CTCA', 'CTCC', 'CTCG', 'CTCT', 'CTGA', 'CTGC', 'CTGG', 'CTGT', 'CTTA', 'CTTC', 'CTTG', 'CTTT', 'GAAA', 'GAAC', 'GAAG', 'GAAT', 'GACA', 'GACC', 'GACG', 'GACT', 'GAGA', 'GAGC', 'GAGG', 'GAGT', 'GATA', 'GATC', 'GATG', 'GATT', 'GCAA', 'GCAC', 'GCAG', 'GCAT', 'GCCA', 'GCCC', 'GCCG', 'GCCT', 'GCGA', 'GCGC', 'GCGG', 'GCGT', 'GCTA', 'GCTC', 'GCTG', 'GCTT', 'GGAA', 'GGAC', 'GGAG', 'GGAT', 'GGCA', 'GGCC', 'GGCG', 'GGCT', 'GGGA', 'GGGC', 'GGGG', 'GGGT', 'GGTA', 'GGTC', 'GGTG', 'GGTT', 'GTAA', 'GTAC', 'GTAG', 'GTAT', 'GTCA', 'GTCC', 'GTCG', 'GTCT', 'GTGA', 'GTGC', 'GTGG', 'GTGT', 'GTTA', 'GTTC', 'GTTG', 'GTTT', 'TAAA', 'TAAC', 'TAAG', 'TAAT', 'TACA', 'TACC', 'TACG', 'TACT', 'TAGA', 'TAGC', 'TAGG', 'TAGT', 'TATA', 'TATC', 'TATG', 'TATT', 'TCAA', 'TCAC', 'TCAG', 'TCAT', 'TCCA', 'TCCC', 'TCCG', 'TCCT', 'TCGA', 'TCGC', 'TCGG', 'TCGT', 'TCTA', 'TCTC', 'TCTG', 'TCTT', 'TGAA', 'TGAC', 'TGAG', 'TGAT', 'TGCA', 'TGCC', 'TGCG', 'TGCT', 'TGGA', 'TGGC', 'TGGG', 'TGGT', 'TGTA', 'TGTC', 'TGTG', 'TGTT', 'TTAA', 'TTAC', 'TTAG', 'TTAT', 'TTCA', 'TTCC', 'TTCG', 'TTCT', 'TTGA', 'TTGC', 'TTGG', 'TTGT', 'TTTA', 'TTTC', 'TTTG', 'TTTT']\n417 417 349 430 365 405 410 400 350 386 380 378 378 419 398 363 368 370 383 354 396 378 384 375 393 387 381 381 370 388 386 401 377 388 380 411 386 370 377 366 388 383 401 385 376 394 359 372 358 406 382 369 385 403 401 394 361 357 365 403 385 394 359 402 400 381 383 384 364 386 369 372 399 401 394 373 364 364 349 393 372 401 389 374 377 420 371 340 367 370 397 387 393 397 376 369 389 391 375 372 374 375 393 388 362 425 357 404 388 367 410 386 370 368 399 403 376 367 427 358 383 388 365 378 366 396 381 384 388 388 405 363 366 381 368 392 427 346 381 353 412 370 349 409 381 376 411 370 374 354 381 373 372 374 364 410 399 362 380 365 370 377 359 381 408 389 379 393 392 376 348 377 392 379 332 386 410 389 390 376 394 407 363 389 388 355 342 383 409 354 367 381 408 394 357 381 380 361 395 381 380 366 402 397 361 430 390 375 427 344 384 372 389 356 385 447 395 399 406 373 378 381 372 392 408 351 394 376 370 348 371 359 345 384 387 323 409 413 367 367 402 354 374 408 372 400 382 382 397 348 367 392 378 392 397 393 \n\n\n\n\n37 Speeding Up Motif Finding\n\ndef speed_up_motif(seq: str)-&gt;str:\n    \"\"\"\n        This function returns the failure array of a DNA string.\n        -----\n        Parameters:\n        - seq (str): a DNA string\n        -----\n        Returns:\n        - (str): the failure array\n    \"\"\"\n    ans = \"\"\n\n    ## construct 0 array\n    arr = []\n\n    for i in range(len(seq)):\n        arr.append(0)\n\n    for i in range(1, len(seq)):\n        cumm = 0\n        for j in range(len(seq)):\n            if j + i &lt; len(seq) and seq[j] == seq[j+i]:\n                cumm += 1\n                if cumm &gt; arr[j+i]:\n                    arr[j+i] = cumm\n            else:\n                break\n    \n    with open(\"../data/results/results_motif.txt\", \"w\") as f:\n        ans = \"\"\n        for each in arr:\n            ans += str(each) + \" \"\n        f.write(ans)\n    return ans\n\n\nprint(speed_up_motif(\"AAACAAAAAAGCTGATAAAAGATTGCC\"))\n\n0 1 2 0 1 2 3 3 3 3 0 0 0 0 1 0 1 2 3 3 0 1 0 0 0 0 0 \n\n\n\n\n38 Finding a Shared Spliced Motif\n\ndef longest_common_subsequence(seq_1, seq_2)-&gt;str:\n    \"\"\"\n        This function finds the longest common subsequence of 2 strings.\n        -----\n        Parameters:\n        - seq_1, seq_2 (str): 2 DNA strings\n        -----\n        Returns:\n        - the longest common subsequence\n    \"\"\"\n    seq_len_1 = len(seq_1)\n    seq_len_2 = len(seq_2)\n    \n    # Initialize the dp matrix with 0s\n    mat = [[0] * (seq_len_2 + 1) for _ in range(seq_len_1 + 1)]\n    \n    # Fill the dp matrix\n    for i in range(1, seq_len_1 + 1):\n        for j in range(1, seq_len_2 + 1):\n            if seq_1[i - 1] == seq_2[j - 1]:\n                mat[i][j] = mat[i - 1][j - 1] + 1\n            else:\n                mat[i][j] = max(mat[i - 1][j], mat[i][j - 1])\n    \n    lcs = []\n    i, j = seq_len_1, seq_len_2\n    while i &gt; 0 and j &gt; 0:\n        if seq_1[i - 1] == seq_2[j - 1]:\n            lcs.append(seq_1[i - 1])\n            i -= 1\n            j -= 1\n        elif mat[i - 1][j] &gt; mat[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return ''.join(lcs[::-1])\n\n\nwith open(\"../data/rosalind/rosalind_lcsq.txt\", \"r\") as file:\n    text = file.read().split(\"&gt;\")[1:]\n    seq_1 = text[0].split(\"\\n\")[1:]\n    seq_2 = text[1].split(\"\\n\")[1:]\n    seq_1 = \"\".join(seq_1)\n    seq_2 = \"\".join(seq_2)\n    print(longest_common_subsequence(seq_1, seq_2))\n\nACCTGG\n\n\n\n\n39 Ordering Strings of Varying Length Lexicographically\n\nfrom typing import List\ndef helper(results_str, to_multi):\n    \"\"\"\n        This helper function help multiply previous sequences with the original\n        to form new permutations of strings (ordered lexicographically)\n    \"\"\"\n    new = []\n    results_str = [\"\"] + results_str\n    for i in range(len(to_multi)):\n        for j in range(len(results_str)):\n            new.append(to_multi[i] + results_str[j])\n    return new\n\ndef order_strings_lex(results_str, seq_str: List, k: int)-&gt;str:\n    \"\"\"\n        This function returns all strings of length at most k formed from seq_str\n        -----\n        Parameters:\n        - results_str (list): the list of currently calculated permutations\n        - seq_str (list): the original list of alphabets\n        - k (int): the maximum length of strings formed\n        -----\n        Returns:\n        - (str): all strings permutations, ordered\n\n    \"\"\"\n    to_multi = [] + seq_str\n    if k == 1:\n        return results_str    \n    return helper(order_strings_lex(results_str, seq_str, k - 1), to_multi)\n\n\nwith open(\"../data/rosalind/rosalind_lexv.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    li = list(text[0].split(\" \"))\n    num = int(text[1])\n    ans = order_strings_lex(li, li, num)\n\nwith open(\"../data/results/results_lexv.txt\", \"w\") as f:\n    for each in ans:\n        f.write(each)\n        f.write(\"\\n\")\n\n\n\n40 Maximum Matchings and RNA Secondary Structures\n\ndef maximum_matching(seq: str)-&gt;int:\n    \"\"\"\n        This function calculates the total possible number of maximum matchings \n        of basepair edges in the bonding graph seq.\n        -----\n        Parameters:\n        - seq (str): the sequence to form the bonding graph\n        -----\n        Returns:\n        - (int): the number of maximum matchings\n    \"\"\"\n    dict = {}\n    for char in seq:\n        if char not in dict:\n            dict[char] = 1\n        else:\n            dict[char] += 1\n\n    max_AU, min_AU = max(dict[\"A\"], dict[\"U\"]), min(dict[\"A\"], dict[\"U\"])\n    max_GC, min_GC = max(dict[\"G\"], dict[\"C\"]), min(dict[\"G\"], dict[\"C\"])\n\n    AU_matching = math.factorial(max_AU) // math.factorial(max_AU-min_AU)\n    GC_matching = math.factorial(max_GC) // math.factorial(max_GC-min_GC)\n    num_matching = AU_matching*GC_matching\n    return num_matching\n\n\nwith open(\"../data/rosalind/rosalind_mmch.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[1:]\n    seq = \"\".join(text)\n    print(maximum_matching(seq))\n\n1606334820229118893611815798833152000000000",
    "crumbs": [
      "Rosalind",
      "31-40"
    ]
  },
  {
    "objectID": "rosalind_markdowns/1_10.html",
    "href": "rosalind_markdowns/1_10.html",
    "title": "1-10",
    "section": "",
    "text": "1 Counting DNA nucleotides\n\ndef DNA_count(sequence: str) -&gt; str:\n    \"\"\"\n        This function counts the number of nucleotides present in a given DNA sequence\n        -----\n        Parameters:- sequence (str): the DNA sequence\n        -----\n        Returns- counts (str): a string represents the counts of A, C, G, T in their respective order \n    \"\"\"\n\n    answer = \"\"\n    dna_count = {\"A\" : 0, \"C\" : 0, \"G\": 0, \"T\" : 0}\n    for i in range(len(sequence)):\n        nucleotide = sequence[i]\n        dna_count[nucleotide] += 1\n    \n    for nucleotide in dna_count.values():\n        answer += str(nucleotide) + \" \"\n\n    return answer[:-1]\n\n\n## Test case:\nprint(DNA_count(\"AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTG\"))\n\n17 10 15 20\n\n\n\n\n2 Transcribing DNA to RNA\n\ndef transcription(DNA_seq: str) -&gt; str:\n    \"\"\"\n    This function transcribes a DNA sequence into an RNA sequence\n    -----\n    Parameters:\n    - DNA_seq (str): a DNA sequence string to be transcribed\n    \n    -----\n    Returns:\n    - RNA_seq (str): the transcribed RNA sequence\n    \"\"\"\n    return DNA_seq.replace(\"T\", \"U\")\n\n\nprint(transcription(\"GATGGAACTTGACTACGTAAATT\"))\n\nGAUGGAACUUGACUACGUAAAUU\n\n\n\n\n3 Complementing a strand of DNA\n\ndef DNA_complementary(DNA_seq: str) -&gt; str:\n    \"\"\"\n        This function returns the complementary strand of a given DNA sequence\n        -----\n        Parameters:\n        - DNA_seq (str): the DNA sequence string\n        -----\n        Returns:\n        - DNA_com (str): the complementary strand\n    \"\"\"\n    complementary = {\"A\" : \"T\", \"T\" : \"A\", \"C\" : \"G\", \"G\" : \"C\"}\n    DNA_com = \"\"\n    for nucleotide in DNA_seq:\n        DNA_com += complementary[nucleotide]\n    return DNA_com[::-1]\n\n\nprint(DNA_complementary(\"AAAACCCGGT\"))\n\nACCGGGTTTT\n\n\n\n\n4 Rabbits & Recurrence Relations\n\ndef wascally_wabbits(n: int, k: int)-&gt; int:\n    \"\"\"\n        This function counts the number of rabbits in the n-th generation,\n        provided that each pair gives birth to k-pairs\n        -----\n        Parameters:\n        - n (int): the number of generations\n        - k (int): the number of rabbits pairs one give birth to\n    \"\"\"\n    if n &gt; 2:\n        return wascally_wabbits(n - 2, k)*k + wascally_wabbits(n - 1, k)\n    else:\n        return 1\n\n\nprint(\"After 6 gens, provided that a pair gives birth to 6 pairs we have:\")\nprint(wascally_wabbits(6, 3))\n\nprint(\"After 29 gens, provided that a pair gives birth to 4 pairs we have:\")\nprint(wascally_wabbits(29, 4))\n\nAfter 6 gens, provided that a pair gives birth to 6 pairs we have:\n40\nAfter 29 gens, provided that a pair gives birth to 4 pairs we have:\n170361678269\n\n\n\n\n5 Computing GC Contents\n\ndef GC_contents(FASTA: str) -&gt; str:\n    \"\"\"\n        This function computes the GC-content of a given FASTA file and returns\n        the sequences with the highest GC contents.\n        The GC-content is defined as the percentage of G/C nucleotide among\n        all nucleotides in the string\n        -----\n        Parameters:\n        - FASTA (str): the sequences in FASTA formats\n        -----\n        Returns:\n        - (str): a string represents (1) Sequence identifier, (2) GC %\n    \"\"\"\n    fasta_seq = FASTA.split(\"&gt;\")\n    GC_content = {}\n    for a_seq in fasta_seq:\n        if len(a_seq) == 0:\n            continue\n        seq = a_seq.split(\"\\n\")\n        GC_count = 0\n        for char in seq[1]:\n            if char == \"C\" or char == \"G\":\n                GC_count +=1\n        GC_content[seq[0]] = GC_count/len(seq[1])\n    print(GC_content)\n    results = sorted(GC_content.items())[0]\n    return results[0] + \"\\n\" + str(results[1])\n\n\nwith open(\"../data/rosalind/rosalind_qc.txt\", \"r\") as file:\n  print(GC_contents(file.read()))\n\n{'Rosalind_6404': 0.5375, 'Rosalind_5959': 0.5357142857142857, 'Rosalind_0808': 0.6091954022988506}\nRosalind_0808\n0.6091954022988506\n\n\n\n\n6 Counting Point Mutations\n\ndef point_mutations(s_seq: str, t_seq: str) -&gt; int:\n    \"\"\"\n        This function counts the number of point mutations on a sequence using\n        its reference sequence\n        -----\n        Parameters:\n        - s_seq (str): the reference DNA sequence\n        - t_seq (str): the sequence to compute mutations\n        -----\n        Returns:\n        - (int): the number of point mutations in t_seq\n    \"\"\"\n    if (len(s_seq) != len(t_seq)):\n        return 0\n    else:\n        point_mut = 0\n        for i in range(len(s_seq)):\n            if s_seq[i] != t_seq[i]:\n                point_mut += 1\n    return point_mut\n\n\nmut_counts = point_mutations(\"GAGCCTACTAACGGGAT\", \"CATCGTAATGACGGCCT\")\nprint(\"The number of mutations:\", mut_counts)\n\nThe number of mutations: 7\n\n\n\n\n7 Mendel’s First Law\n\ndef mendelian(k: int, m: int, n: int) -&gt; float:\n    \"\"\"\n        This function calculates the probability of two randomly selected mating organisms\n        producing an individual possessing a dominant allele\n        -----\n        Parameters:\n        - k (int): number of dominants homozygous individuals (AA)\n        - m (int): number of heterozygous individuals (Aa)\n        - n (int): number of recessive homozygous individuals (aa)\n        -----\n        Returns:\n        - (float): the probability of dominants homozygous individuals\n        in the population for the next generation\n    \"\"\"\n    total =  k + m + n\n    hetero_prob = 0.25*(m/total)*(m-1)/(total-1) + (m/total)*n/(total-1)\n    homo_recessive_prob = (n/total) * ((n-1)/(total-1))\n    return 1 - hetero_prob - homo_recessive_prob\n\n\nprint(mendelian(26, 19, 16))\n\n0.8280054644808743\n\n\n\n\n8 Translation of RNA to protein\n\ndef translation(RNA_seq: str) -&gt; str:\n    \"\"\"\n        This function translates the RNA sequence into a protein using the\n        codon table (in data/ref folder).\n        -----\n        Parameters:\n        - RNA_seq (str): an RNA sequence to be translated\n        -----\n        Returns:\n        - protein (str): the encoded protein sequence\n    \"\"\"\n    with open(\"../data/ref/codon.txt\", \"r\") as file:\n        text = [line.replace(\"\\n\", \"\").split(\" \") for line in file.readlines()]\n        codon_table = {}\n        protein = \"\"\n        for line in text:   \n            line = [x for x in line if x != '']\n            for i in range(len(line) // 2):\n                codon_table[line[i*2]] = line[i*2+1]\n        for i in range(len(RNA_seq) // 3):\n            codon = RNA_seq[i*3:i*3+3]\n            protein += codon_table[codon] if codon_table[codon] != \"Stop\" else \"\"\n    return protein\n\n\nprint(translation(\"AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA\"))\n\nMAMAPRTEINSTRING\n\n\n\n\n9 Finding a Motif in DNA\n\ndef motif_check(s_str: str, t_str: str) -&gt; str:\n    \"\"\"\n        This function finds a motif within a DNA sequence.\n        -----\n        Parameters:\n        - s_str (str): the DNA sequence \n        - t_str (str): the motif to look up\n        -----\n        Returns:\n        - (str): a string of starting position of the motif\n    \"\"\"\n    answer = \"\"\n    for i in range(len(s_str) - len(t_str)):\n        t_len = len(t_str)\n        if s_str[i:i + t_len] == t_str:            \n            answer += str(i+1) + \" \"\n    return answer[:-1]\n\n\nprint(motif_check(\"GATATATGCATATACTT\", \"ATAT\"))\n\n2 4 10\n\n\n\n\n10 Consensus and Profile\n\nfrom typing import List\nimport pandas as pd\nimport numpy as np\n\ndef consensus_and_profile(file):\n    \"\"\"\n        This function construct a consensus and a profile matrix from multiple\n        DNA sequences. The answer is written into a new file.\n        -----\n        Parameters:\n        - file: the input file containing DNA sequences\n    \"\"\"\n    DNA_len = 942\n    a_dict = {\"A\" : np.zeros(DNA_len), \"C\" : np.zeros(DNA_len), \n                    \"G\" : np.zeros(DNA_len), \"T\" : np.zeros(DNA_len)}\n    with open(file, \"r\") as f:\n        text = f.read().split(\"&gt;\")\n        for DNA_seq in text:\n            DNA_seq = \"\".join(DNA_seq.split(\"\\n\")[1:])\n            if len(DNA_seq) == 0:\n                continue\n            for i in range(DNA_len):\n                nucleotide = DNA_seq[i]\n                a_dict[nucleotide][i] += 1\n        profile = []\n        for nucleotide in a_dict.values():\n            profile.append(nucleotide)\n        profile = pd.DataFrame(profile, index=[\"A\", \"C\", \"G\", \"T\"])\n        consensus = \"\"\n        for i in range(DNA_len):\n            max_nucleotide = profile[i].idxmax()\n            consensus +=str(max_nucleotide)\n    with open(\"../data/results/cons_result.txt\", \"w\") as file:\n        file.write(consensus + \"\\n\")\n        for nucleotide, values in a_dict.items():\n            file.write(nucleotide + \": \")\n            for value in values:\n                file.write(str(int(value)) + \" \")\n            file.write(\"\\n\")\n\n\nconsensus_and_profile(\"../data/rosalind/rosalind_cons.txt\")",
    "crumbs": [
      "Rosalind",
      "1-10"
    ]
  },
  {
    "objectID": "reading/paper.html",
    "href": "reading/paper.html",
    "title": "anti-PD1 treatment for BC patients",
    "section": "",
    "text": "Full title: A single-cell map of intratumoral changes during anti-PD1 treatment of patients with breast cancer\nDOI: https://doi.org/10.1038/s41591-021-01323-8",
    "crumbs": [
      "Reading comprehension",
      "anti-PD1 treatment for BC patients"
    ]
  },
  {
    "objectID": "reading/paper.html#about-single-cell-rna-seq",
    "href": "reading/paper.html#about-single-cell-rna-seq",
    "title": "anti-PD1 treatment for BC patients",
    "section": "About single-cell RNA-seq",
    "text": "About single-cell RNA-seq\n(WHAT) is single-cell RNA-seq?\nSingle-cell RNA-seq is a method used to implement analysis in individual cells (in contrast with original bulk RNA-seq) in order to get a more thorough understanding of the cells in context of its microenvironment.\n(WHY) do single-cell RNA-seq?\nWhen performing traditional bulk RNA-seq, the challenges remains for scientist to dissect the details of the results. For example, are these data showing gene expression of all the tumorous cells, or is the it a compilation of healthy and malignant? Traditional technique average out all the information of mixture of cells, hence making it difficult to if we were to study a specific cell types among those.\nSingle-cell sequencing can identify different cell subtypes with the data, where many thousands of cells are processed at the same time. They can be then clustered to identify the types, and then used to further explore the targets.\n(HOW) is single-cell RNA-seq done?\nSingle-cell RNA-seq consists of the following steps:\n\nCell isolation on ice\nRNA reverse transcription\nLibrary preparation\nSequencing\nPreprocessing (Read alignment, normalization, PCA?)\nCell clustering and subtype clustering",
    "crumbs": [
      "Reading comprehension",
      "anti-PD1 treatment for BC patients"
    ]
  },
  {
    "objectID": "reading/paper.html#study-overview",
    "href": "reading/paper.html#study-overview",
    "title": "anti-PD1 treatment for BC patients",
    "section": "Study overview",
    "text": "Study overview\nThis paper investigates whether the use of anti-PD1 (one dose of pembrolizumab) on breast cancer patients was able to alter biomarkers related to intratumoral immunity and proliferation.\nBasic steps are below:",
    "crumbs": [
      "Reading comprehension",
      "anti-PD1 treatment for BC patients"
    ]
  },
  {
    "objectID": "reading/paper.html#investigative-questions",
    "href": "reading/paper.html#investigative-questions",
    "title": "anti-PD1 treatment for BC patients",
    "section": "Investigative questions",
    "text": "Investigative questions\n\nWhat information to gather from the paper to re-analyze the paper and use the data for future big data research purposes\nRe-analyzing this paper requires:\nData:\n\nRaw-sequencing reads of scRNA-seq, scTCR-seq and CITE-seq. The access to those data can be found at the European Genomephenome Archive (EGA) under data accession number EGAD00001006608\ngnomAD database is used to filter tumor exome-seq data for somatic mutations.\n\nInformation:\n\nTools & methods used: which softwares/tools were used in this experiment? What are the hyperparameters settings (if any).\nThe antibodies used in the study\nSamples characteristics & clinical data\n\n\n\nCan you provide an explanation of how single-cell RNA sequencing experiments were specifically designed to study the topic?\nThe sequencing experiments were designed as follow:\n\nBiopsies were obtained pre-treatment and on-treatment and then subjected to single-cell disassociation on ice. The cells are then filtered after removal of red blood cells and number of living cells were determined using a LUNA cell counter.\nSingle-cell TCR-seq and 5’ gene expression profiling was performed with upto 5000 cells are loaded to the cartridge for each sample.\nPerformed subcluster T cells from pre- and on-treatment samples using the integration pipeline of Seurat.\n\n\n\nFrom the paper, list the major cell types and their marker genes\nMajor cell types:\n\nT cells have the marker genes: CD3D, CD3E, CD2\nFibroblast have the marker genes: COL1A1, DCN, C1R\nMyeloid cells, their markers are: CLEC9A, XCR1, CD1C, CCR7, CCL17, CCL19 (cCDs) and CD1A, CD207 (Langerhans-like)\nCancer cells have the marker genes CD24, KRT19, SCGB2A2\nB cells have the marker genes: CD79A, MZB1, MS4A1\n\n\n\nFrom the paper, list the cell subtypes\nT cells have the following cell subtypes:\n\nCD4+ and CD8+ naive T cells (TN)\nCD4+ and CD8+ experienced T cells (TEX), which the former were further split into type-1 helper (TH1) and follicular helper (TFH)\nCD4+ regulatory T cells (TREG)\nCD8+ effector/memory T cells (TEM)\nCD8+ resident-memory T cells (TRM)\nCD8+ activated effector/memory T cells (TEMRA)\n\n\nDendritic cells have the following cell subtypes:\n\nConventional type 1 and 2 dendritic cells (cDC1, cDC2)\nPlasmacytoid dendritic cells (pDC)\nLangerhans-like dendritic cells (LanghDC)\nMigratory dendritic cells (migDC)\nAXL+SIGLEC6+ dendritic cells (ASDC)\n\nMacrophages have the following subtypes:\n\nC3-C10 macrophages\nC7_MT1G macrophages\nHypoxic C8_SLC2A1 macrophages\n\n\n\nWhat information or data was NOT further investigated by the author that might hold potential for significant findings?\nFrom the paper, I think that we can investigate further on how tumor-associated macrophages influence the clinical benefits (or clonotype expansion) of said patients. From what I’ve learned, TAMs can suppress the activity of T cells, and perhaps they could interfere with T cells expansion. Hence, understanding this might give a bit light into why the expansion works on some patients and not for the rest.\nTechnically, I think after isolating, preprocessing and clustering the macrophages, we can perform pathway enrichment analysis or network analysis using deep learning methods.\n\n\nWhat new knowledge or insights did you acquire from reading this paper, stated in your own words?\nHere are the things that I have learned (a lot actually but these are the main things):\n(1) On various T-cell types:\n\nExhausion of T cell was induced by multiple checkpoint molecules (PD1, Tim3, Lag3, Tigit…). The blockage of just one ICB (in this case PD1), might be insufficient to gain clinical benefits. Therefore people would want to attempt to block multiple checkpoints, as this would benefit more, yet overdoing this might lead to disequilibrium, and therefore could even harm the body.\n\n(2) Tumor formation and its battle with the immune system:\nFrom what I read, I’d like to simplify the process as below:\n\nTumor is formed when cells undergo weird mutations, that could have been the products of oncogenes (these should be turned off after the embryonic phase but mutations turn them on again) -&gt; driving an uncontrollable cycle of the cell.\nMore and more nearby cells experience these mutations, and they form a tumor.\nThe immune system might have recognized already tumorous cells and tried to kill them, but unsuccesful attempts led to tumor formation.\nAccording to The hallmark of cancer, tumor cells have ways to evade the immune system, one of which is utilizing the immune checkpoint to abstain the cytotoxic T cells from destroying it.\nIf they are successful in their own schemes -&gt; tumor won the immune system by recruiting them to assist them as well! (such as macrophages can be asked to avoid attacks from other T cells, or forming more blood vessels that aid the nutritional pathway to the cancer) and slowly becoming bigger and bigger.\n\n(3)The thinking process of this study is very meticulous\n\nI actually (in an attempt) tried to answer the question of “what can be further investiaged” by researching on what others are doing in the same topic. But no matter what new buzzwords or concepts I read about, it appears that this paper has done it. It also might be due to my lack of expertise, but everything ranging from GSEA to cell-cell interactions, the paper has done it, which is cool.\nI tried to think of the process of this paper, from Result 1 to the end. It was incredible to me how they came up with the entire process, and how the results supports each other, and I got inspired to learn about this topic more.\nThere’s so many things I don’t know! (but eager to learn)",
    "crumbs": [
      "Reading comprehension",
      "anti-PD1 treatment for BC patients"
    ]
  },
  {
    "objectID": "rosalind_markdowns/11_20.html",
    "href": "rosalind_markdowns/11_20.html",
    "title": "11-20",
    "section": "",
    "text": "11 Mortal Fibonacci Rabbits\n\ndef mortal_rabbits(n: int, m: int):\n    \"\"\"\n        This function returns the number of rabbits alive after n generations,\n        provided that they live for m generations, and give birth to one pair\n        in each matured generation.\n        -----\n        Parameters:\n        - n (int): the total generations to account for\n        - m (int): the lifespan of a rabbit\n        -----\n        Returns:\n        - (int): the total number of living rabbits\n    \"\"\"\n    ## Initializing a list to hold rabbits_num in m generations\n    ls = [1, 0, 1]\n    for j in range(3, m):\n        ls.append(0)\n\n    ## For each generation, the mature rabbits give birth to more, and they\n    ## move to the next gen\n    for i in range(3, n):\n        new_ls = []\n        summ = sum(ls[1:])\n        new_ls.append(summ)\n        for j in range(1, len(ls)):\n            new_ls.append(ls[j-1])\n        ls = new_ls\n    return sum(ls[:])\n\nTest case\n\nprint(mortal_rabbits(89, 16))\n\n1753129196882635810\n\n\n\n\n12 Overlap graphs\n\ndef overlap_graph(file, k:int):\n    \"\"\"\n        This function returns the sequences that overlaps (or connected) with\n        each other, suppose that each sequence is a node, the connection\n        between them is considered as a graph. The answer is written to a file\n        -----\n        Parameters:\n        - file: the file to extract sequences from\n        - k (int): the number of characters forming the prefix or suffix\n        -----\n        - Returns: the string where each line is 2 adjacent nodes\n        \n    \"\"\"\n    with open(file, \"r\") as f:\n        text = f.read().split(\"&gt;\")[1:]\n        answer = \"\"\n        graph_dict = {}\n        \n        for string in text:\n            strs = string.split(\"\\n\")\n            graph_dict[strs[0]] = \"\".join(strs[1:])\n        for key, value in graph_dict.items():\n            suffix = value[-k:]\n            for key_i, value_i in graph_dict.items():\n                if key_i != key:\n                    prefix_i = value_i[:k]\n                    if suffix == prefix_i:\n                        answer += key + \" \" + key_i + \"\\n\"\n    with open(\"../data/results/results_graph.txt\", \"w\") as f:\n        f.write(answer)\n    return answer\n\n\nprint(overlap_graph(\"../data/rosalind/rosalind_grph.txt\", 3))\n\nRosalind_9150 Rosalind_9942\nRosalind_9150 Rosalind_5326\nRosalind_5388 Rosalind_7112\nRosalind_5388 Rosalind_5169\nRosalind_7879 Rosalind_7381\nRosalind_7879 Rosalind_4589\nRosalind_4234 Rosalind_1733\nRosalind_4234 Rosalind_5315\nRosalind_4234 Rosalind_1800\nRosalind_2228 Rosalind_9942\nRosalind_2228 Rosalind_5326\nRosalind_6132 Rosalind_3410\nRosalind_6132 Rosalind_6551\nRosalind_3461 Rosalind_5505\nRosalind_5267 Rosalind_3461\nRosalind_5267 Rosalind_7526\nRosalind_5267 Rosalind_7075\nRosalind_1550 Rosalind_5121\nRosalind_2881 Rosalind_3451\nRosalind_2881 Rosalind_5620\nRosalind_2881 Rosalind_7972\nRosalind_7112 Rosalind_7879\nRosalind_7112 Rosalind_1201\nRosalind_6583 Rosalind_6147\nRosalind_6222 Rosalind_6121\nRosalind_6222 Rosalind_8679\nRosalind_6222 Rosalind_8901\nRosalind_9462 Rosalind_2443\nRosalind_9462 Rosalind_4297\nRosalind_6156 Rosalind_3461\nRosalind_6156 Rosalind_7526\nRosalind_6156 Rosalind_7075\nRosalind_9102 Rosalind_5588\nRosalind_9102 Rosalind_2883\nRosalind_3451 Rosalind_2228\nRosalind_3451 Rosalind_6132\nRosalind_0954 Rosalind_7112\nRosalind_0954 Rosalind_5169\nRosalind_6702 Rosalind_3919\nRosalind_6702 Rosalind_7567\nRosalind_6702 Rosalind_1196\nRosalind_6702 Rosalind_0727\nRosalind_3919 Rosalind_0942\nRosalind_3919 Rosalind_2909\nRosalind_5231 Rosalind_1468\nRosalind_3278 Rosalind_1485\nRosalind_3278 Rosalind_8164\nRosalind_3410 Rosalind_3756\nRosalind_3410 Rosalind_3261\nRosalind_7526 Rosalind_9942\nRosalind_7526 Rosalind_5326\nRosalind_5121 Rosalind_6512\nRosalind_0942 Rosalind_7112\nRosalind_0942 Rosalind_5169\nRosalind_8044 Rosalind_1485\nRosalind_8044 Rosalind_8164\nRosalind_2443 Rosalind_6702\nRosalind_6136 Rosalind_4581\nRosalind_6136 Rosalind_1568\nRosalind_8232 Rosalind_6512\nRosalind_1468 Rosalind_6512\nRosalind_6386 Rosalind_7381\nRosalind_6386 Rosalind_4589\nRosalind_7567 Rosalind_1733\nRosalind_7567 Rosalind_5315\nRosalind_7567 Rosalind_1800\nRosalind_2883 Rosalind_9942\nRosalind_2883 Rosalind_5326\nRosalind_1733 Rosalind_0954\nRosalind_8461 Rosalind_6222\nRosalind_4614 Rosalind_3461\nRosalind_4614 Rosalind_7526\nRosalind_4614 Rosalind_7075\nRosalind_2328 Rosalind_5704\nRosalind_7874 Rosalind_7429\nRosalind_1485 Rosalind_8044\nRosalind_1485 Rosalind_1111\nRosalind_5315 Rosalind_1485\nRosalind_5315 Rosalind_8164\nRosalind_1196 Rosalind_1733\nRosalind_1196 Rosalind_5315\nRosalind_1196 Rosalind_1800\nRosalind_8679 Rosalind_5267\nRosalind_8679 Rosalind_9462\nRosalind_8679 Rosalind_4302\nRosalind_6567 Rosalind_1587\nRosalind_9210 Rosalind_6567\nRosalind_6443 Rosalind_7115\nRosalind_6443 Rosalind_0482\nRosalind_6443 Rosalind_8461\nRosalind_6512 Rosalind_6147\nRosalind_1460 Rosalind_1550\nRosalind_1460 Rosalind_4493\nRosalind_3797 Rosalind_4581\nRosalind_3797 Rosalind_1568\nRosalind_6620 Rosalind_5121\nRosalind_4297 Rosalind_5267\nRosalind_4297 Rosalind_9462\nRosalind_4297 Rosalind_4302\nRosalind_5620 Rosalind_5267\nRosalind_5620 Rosalind_9462\nRosalind_5620 Rosalind_4302\nRosalind_8901 Rosalind_5388\nRosalind_4581 Rosalind_5704\nRosalind_6147 Rosalind_6567\nRosalind_1201 Rosalind_3656\nRosalind_6603 Rosalind_7879\nRosalind_6603 Rosalind_1201\nRosalind_1568 Rosalind_6512\nRosalind_3656 Rosalind_6567\nRosalind_5505 Rosalind_1485\nRosalind_5505 Rosalind_8164\nRosalind_8629 Rosalind_2182\nRosalind_5704 Rosalind_6386\nRosalind_1800 Rosalind_1550\nRosalind_1800 Rosalind_4493\nRosalind_8028 Rosalind_6121\nRosalind_8028 Rosalind_8679\nRosalind_8028 Rosalind_8901\nRosalind_4637 Rosalind_2881\nRosalind_3756 Rosalind_5231\nRosalind_3756 Rosalind_2857\nRosalind_3756 Rosalind_4568\nRosalind_3756 Rosalind_6620\nRosalind_0461 Rosalind_5231\nRosalind_0461 Rosalind_2857\nRosalind_0461 Rosalind_4568\nRosalind_0461 Rosalind_6620\nRosalind_8164 Rosalind_6567\nRosalind_7972 Rosalind_7879\nRosalind_7972 Rosalind_1201\nRosalind_6551 Rosalind_6147\nRosalind_3261 Rosalind_5231\nRosalind_3261 Rosalind_2857\nRosalind_3261 Rosalind_4568\nRosalind_3261 Rosalind_6620\nRosalind_2909 Rosalind_5704\nRosalind_1855 Rosalind_1485\nRosalind_1855 Rosalind_8164\nRosalind_7075 Rosalind_1485\nRosalind_7075 Rosalind_8164\nRosalind_8487 Rosalind_7429\nRosalind_8515 Rosalind_7152\nRosalind_8515 Rosalind_0461\nRosalind_2182 Rosalind_0942\nRosalind_2182 Rosalind_2909\nRosalind_7381 Rosalind_3461\nRosalind_7381 Rosalind_7526\nRosalind_7381 Rosalind_7075\nRosalind_4785 Rosalind_7115\nRosalind_4785 Rosalind_0482\nRosalind_4785 Rosalind_8461\nRosalind_0727 Rosalind_2182\nRosalind_5326 Rosalind_7112\nRosalind_5326 Rosalind_5169\nRosalind_4589 Rosalind_3919\nRosalind_4589 Rosalind_7567\nRosalind_4589 Rosalind_1196\nRosalind_4589 Rosalind_0727\n\n\n\n\n\n13 Calculating Expected Offspring\n\nfrom typing import List\n\ndef expected_offstring(ls: List) -&gt; float:\n    \"\"\"\n        This function calculates the number of expected offsprings displaying the \n        dominant phenotype in the next generation, given that every couple has \n        exactly two offspring.\n        -----\n        Parameters:\n        - ls (List): a list of number of parents with each phenotype\n        -----\n        Returns:\n        - (float): the expected number of dominant childs\n    \"\"\"\n    expected_child_num = 0\n    phenotype = [1, 1, 1, 0.75, 0.5, 0]\n    for i in range(len(ls)):\n        expected_child_num += float(ls[i])*phenotype[i]\n    return expected_child_num*2\n\n\nwith open(\"../data/rosalind/rosalind_iev.txt\", \"r\") as f:\n    text = f.read().split(\" \")\n    print(expected_offstring(text))\n\n141399.0\n\n\n\n\n14 Finding a Shared Motif\n\nimport re\ndef shared_motif(file) -&gt; str:\n    \"\"\"\n        This function finds the longest common substring of the collection.\n        -----\n        Parameters:\n        - file: the file to be searched\n        -----\n        Returns:\n        - (str): the longest common substring\n    \"\"\"\n    with open(file, \"r\") as f:\n        text = f.read().split(\"&gt;\")[1:]\n        seq_dicts = []\n        for string in text:\n            strs = string.split(\"\\n\")\n            seq_dicts.append(\"\".join(strs[1:]))\n        motifs_ls = longest_common_substr(seq_dicts[0], seq_dicts[1])    \n        lsss = motifs_ls\n        for motif in motifs_ls:\n            for seq in seq_dicts[2:]:\n                if motif not in seq:\n                    lsss.remove(motif)\n                    break\n        return lsss[0]\n\ndef longest_common_substr(str_1, str_2) -&gt; List:\n    \"\"\"\n        This is a helper function for longest common substring\n        -----\n        Parameters:\n        - str_1, str_2 (str): the two strings to search\n        -----\n        Returns:\n        - (List): a list of common susbtrings\n    \"\"\"\n    common_substr = \"\"\n    substrs = []\n    for i in range(len(str_1), 1, -1):\n        rang = len(str_1) - i + 1\n        for j in range(rang):\n            pattern = str_1[j:j+i]\n            if pattern in str_1 and pattern in str_2:\n                common_substr = str_1[j:j+i]\n                substrs.append(common_substr)\n\n    return substrs\n\n\nprint(shared_motif(\"../data/rosalind/rosalind_grph.txt\"))\n\nTTCTAATCGATCACCAGGGTAACAGATTCTGCCTTAGGTAGCCTTGCTAACACCAGTGACGATATGTCCCATAGGGCTCTCAAAGTGAACGCTGATGATGGAGTGTTAGCGTGAGCGAATTAATATTTTCGAGGATCCGGA\n\n\n\n\n15 Independent Alleles\n\nimport math\ndef independent_alleles(k: int, N: int) -&gt; float:\n    \"\"\"\n        This function calculates the probability that at least N AaBb organisms \n        will belong to the k-th generation under Mendel's second law.\n        -----\n        Parameters:\n        - k (int): the generation to calculate from\n        - N (int): the number of organisms expected to fall in AaBb \n    \"\"\"\n    total = 0.0\n    for i in range(N, 2**k + 1):\n        n_fact = math.factorial(2**k)\n        n_k_fact = (math.factorial(i)*math.factorial(2**k-i))\n        binom = n_fact/n_k_fact\n        prob = (1/4)**(i) * (3/4)**(2**k-i) * binom\n        total += prob\n    return total\n\n\nprint(independent_alleles(6, 16))\n\n0.5478689355957752\n\n\n\n\n16 Finding a protein motif\n\nimport requests\nimport re\ndef protein_motif(ls: List) -&gt; str:\n    \"\"\"\n        This function returns the N-glycosylation motif-possessing protein \n        along with the locations of that motif.\n        N-glycosylation motif is under the format N{P}[ST]{P}.\n        -----\n        Parameters:\n        - ls (List): a list of UniProt Protein Database IDs\n        -----\n        Returns:\n        - (str): where each row is a protein, follows by a row of motifs locations\n    \"\"\"\n    answer = \"\"\n    pattern = re.compile(\"(?=(N[^P](S|T)[^P]))\")\n    for protein in ls:\n        print(f\"Looking for protein {protein}\")\n        if \"_\" in protein:\n            protein_id = protein.split(\"_\")[0]\n        else:\n            protein_id = protein\n        info = requests.get(f\"http://www.uniprot.org/uniprot/{protein_id}.fasta\").text\n        protein_seq = \"\".join(info.split(\"\\n\")[1:])\n        locations = \"\"\n\n        for m in pattern.finditer(protein_seq):\n            locations += str(m.start() + 1) + \" \"\n        if locations == \"\":\n            continue\n        answer += protein + \"\\n\" + locations + \"\\n\"\n\n    with open(\"../data/results/results_protein_motif.txt\", \"w\") as f:\n        f.write(answer)\n\n    return answer\n\n\n## Test case\nwith open(\"../data/rosalind/rosalind_mprt.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    print(text)\n    print(protein_motif(text))\n\n['Q4FZD7', 'Q8R1Y2', 'Q90304_C166_CARAU', 'Q32LI2', 'P01044_KNH1_BOVIN', 'P10643_CO7_HUMAN', 'P80069_A45K_MYCBO', 'P28314_PER_COPCI', 'P04233_HG2A_HUMAN', 'B4S2L7', 'Q07287_ZPB_PIG', 'P05783_K1CR_HUMAN', 'B3ET80', 'P04921_GLPC_HUMAN']\nLooking for protein Q4FZD7\nLooking for protein Q8R1Y2\nLooking for protein Q90304_C166_CARAU\nLooking for protein Q32LI2\nLooking for protein P01044_KNH1_BOVIN\nLooking for protein P10643_CO7_HUMAN\nLooking for protein P80069_A45K_MYCBO\nLooking for protein P28314_PER_COPCI\nLooking for protein P04233_HG2A_HUMAN\nLooking for protein B4S2L7\nLooking for protein Q07287_ZPB_PIG\nLooking for protein P05783_K1CR_HUMAN\nLooking for protein B3ET80\nLooking for protein P04921_GLPC_HUMAN\nQ4FZD7\n528 \nQ90304_C166_CARAU\n92 171 350 441 465 \nQ32LI2\n157 \nP01044_KNH1_BOVIN\n47 87 168 169 197 204 \nP10643_CO7_HUMAN\n202 754 \nP80069_A45K_MYCBO\n7 161 \nP28314_PER_COPCI\n162 \nP04233_HG2A_HUMAN\n130 136 256 270 \nB4S2L7\n33 \nQ07287_ZPB_PIG\n70 203 220 333 474 \nP05783_K1CR_HUMAN\n193 423 \nB3ET80\n6 \nP04921_GLPC_HUMAN\n8 \n\n\n\n\n\n17 Inferring mRNA from protein\n\ndef mRNA_inference(protein_seq:str) -&gt; int:\n    \"\"\"\n        This function calculates the total number of different RNA strings \n        from which the given protein sequence could have been translated.\n        -----\n        Parameters:\n        - protein_seq (str): the protein sequence\n        -----\n        Returns:\n        - (int): the number of possible RNA strings\n    \"\"\"\n    total = 1\n    with open(\"../data/ref/codon.txt\", \"r\") as file:\n        text = [line.replace(\"\\n\", \"\").split(\" \") for line in file.readlines()]\n        codon_table = {}\n\n        for line in text:   \n            line = [x for x in line if x != '']\n            \n            for i in range(len(line) // 2):\n                symbol = line[i*2+1]\n                amino_acid = line[i*2]\n                if symbol not in codon_table:\n                    codon_table[symbol] = [amino_acid]\n                else:\n                    codon_table[symbol].append(amino_acid)\n\n    for protein in protein_seq:\n        total *= len(codon_table[protein])\n\n    return total*3 % 1000000\n\n\nwith open(\"../data/rosalind/rosalind_mrna.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    text = \"\".join(text)\n    print(mRNA_inference(text))\n\n548224\n\n\n\n\n18 Open Reading Frames\n\nfrom utils import DNA_complementary, transcription\ndef get_codon_table(aa_first=False) -&gt; dict:\n    \"\"\"\n        This helper function returns the codon table encoding\n        -----\n        Parameters:\n        - aa_first (boolean): whether the keys of dictionary is amino acid\n        -----\n        Returns:\n        - (dict): of aa and symbols\n    \"\"\"\n    with open(\"../data/ref/codon.txt\", \"r\") as file:\n        text = [line.replace(\"\\n\", \"\").split(\" \") for line in file.readlines()]\n        codon_table = {}\n        for line in text:   \n            line = [x for x in line if x != '']\n            if aa_first == True:\n                for i in range(len(line) // 2):\n                    codon_table[line[i*2]] = line[i*2+1]\n            else: \n                for i in range(len(line) // 2):\n                    symbol = line[i*2+1]\n                    amino_acid = line[i*2]\n                    if symbol not in codon_table:\n                        codon_table[symbol] = [amino_acid]\n                    else:\n                        codon_table[symbol].append(amino_acid)\n    return codon_table\n\ndef orf(DNA_seq: str) -&gt; str:\n    \"\"\"\n        This function returns distinct candidate protein string that can be \n        translated from ORF of the DNA sequence\n        -----\n        Parameters:\n        - DNA_seq (str): the DNA sequence to translated\n        -----\n        Returns:\n        - (str): strings of protein string\n    \"\"\"\n    ls_of_seq = []\n    codon_table = get_codon_table()\n    reverse_codon_table = get_codon_table(aa_first=True)\n    stop_codon = codon_table[\"Stop\"]\n    start_codon = \"AUG\"\n    DNA_com = DNA_complementary(DNA_seq)\n    RNA_seq = transcription(DNA_seq)\n    RNA_seq_reverse = transcription(DNA_com)\n\n    for codon in stop_codon:\n        pattern = re.compile(start_codon)\n        for m in pattern.finditer(RNA_seq):\n            seq = \"\"\n            i = m.start()\n            notEnd = True\n            while notEnd:\n                _codon = RNA_seq[i:i+3]\n                i += 3\n                if _codon in stop_codon:\n                    ls_of_seq.append(seq)\n                    break\n                if i &gt;= len(RNA_seq):\n                    break\n                seq += reverse_codon_table[_codon]\n        for m in pattern.finditer(RNA_seq_reverse):\n            seq = \"\"\n            i = m.start()\n            notEnd = True\n            while notEnd:\n                _codon = RNA_seq_reverse[i:i+3]\n                i += 3\n                if _codon in stop_codon:\n                    ls_of_seq.append(seq)\n                    break\n                if i &gt;= len(RNA_seq_reverse):\n                    break\n                seq += reverse_codon_table[_codon]\n    return \"\\n\".join(set(ls_of_seq))\n\n\nwith open(\"../data/rosalind/rosalind_orf.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    text = \"\".join(text)\n    print(orf(text))\n\nMFRSMLDHWLPLR\nM\nMVVLAQSIKEQNHPWVATACYTSCNGLSFPRQLKG\nML\nMGRRGLWILV\nMRDRQAQDTTILIRSSRFFVYTILVFLLHLVVLL\nMAAQTVAVITSK\nMREMGGGAPGPVLNANRPRYHI\nMTVSKLWYPELAGLAWH\nMLLSSMAAQTVAVITSK\nMLDHWLPLR\nMRI\nMKAKALSLYWSDVPKYVGPLATAALANAAVASGPTLPHLKMLVEYNRISYASKDEKLAVYAGDGRWSPRARLERQSTAVSHLSAVQAHS\nMLVEYNRISYASKDEKLAVYAGDGRWSPRARLERQSTAVSHLSAVQAHS\nMKCNKP\nMLQKTKSWRCMREMGGGAPGPVLNANRPRYHI\nMGGGAPGPVLNANRPRYHI\nMACLSPGNSRDES\nMMADPNVKVYFDQLY\nMLDRSIISSFACFTQGARRSRAAVYQRLEVYPRRSRSTTT\nMALKGVTSAPVPRSDVIPRSIGVQDGPGGSTSHLPHTPPTFRLLKHS\nMWVLARLDTSAIIRYGTARFVDISITDQSRLLHWDPPSFTRDNGHGLGGHAR\nMPAASVAFRVKRLSGAETRELYKQRTVMTVSKLWYPELAGLAWH\nMPCETGKLRIPQF\nMADPNVKVYFDQLY\n\n\n\n\n19 Enumerating Gene Orders\n\ndef enumerate_gene_orders(k:int) -&gt; str:\n    \"\"\"\n        This function enumerates the permuation of an ordered list of ints\n        -----\n        Parameters:\n        - k (int): the number of ints from 1 to k\n        -----\n        Returns:\n        - (str): the result including the number of permutations, followed by\n        all the permutations in separate lines\n    \"\"\"\n    answer = \"\"\n    answer += str(point_mutation_enum(k)) + \"\\n\"\n    answer += point_mutation_ways(k)\n    answer = answer.split(\"\\n\")\n    final = answer[0] + \"\\n\"\n    for line in answer[1:]:\n        line = line[1:] + \"\\n\"\n        final += line\n    with open(\"../data/results/results_perm\", \"w\") as f:\n        f.write(final)\n\ndef point_mutation_enum(k: int):\n    if k == 1:\n        return 1\n    else: \n        return k * point_mutation_enum(k-1)\n\ndef point_mutation_ways(k: int):\n    lst = []\n    cur = \"\"\n    for i in range(k):\n        lst.append(str(i+1))\n    cur =  recurse(\"\", lst)\n    return cur\n\ndef recurse(cur, lst):\n    answer = \"\"\n    if len(lst) == 0:\n        return cur + \"\\n\"\n    for i in range(len(lst)):\n        nextChar = lst.pop(i)\n        pr = recurse(cur + \" \" + nextChar, lst)\n        lst.insert(i, nextChar)\n        answer += pr\n    return answer\n\n\nenumerate_gene_orders(6)\n\n\n\n20 Calculating Protein Mass\n\ndef get_mass(file):\n    \"\"\"\n        This function returns the protein mass dictionary given the file location\n    \"\"\"\n    mass_dict = {}\n    with open(file, \"r\") as f:\n        text = f.read().split(\"\\n\")\n        for line in text:\n            line = line.split(\" \")\n            mass_dict[line[0]] = line[-1]\n    return mass_dict\n\ndef protein_mass(seq: str)-&gt;float:\n    \"\"\"\n\n    \"\"\"\n    total_mass = 0.0\n    mass_dict = get_mass(\"../data/ref/mass.txt\")\n    for aa in seq:\n        total_mass += float(mass_dict[aa])\n    return total_mass\n\n\nwith open(\"../data/rosalind/rosalind_mass.txt\", \"r\") as file:\n    print(protein_mass(file.read()))\n\n102582.32414000055",
    "crumbs": [
      "Rosalind",
      "11-20"
    ]
  },
  {
    "objectID": "rosalind_markdowns/21_30.html",
    "href": "rosalind_markdowns/21_30.html",
    "title": "21-30",
    "section": "",
    "text": "21 Locating Restriction Sites\n\nfrom utils import DNA_complementary, transcription\ndef restriction_sites(seq_str: str) -&gt; str:\n    \"\"\"\n        This function returns the postion and length of every reverse palindrome \n        in the string having length between 4 and 12.\n        -----\n        Parameters:\n        - seq_str (str): A DNA string \n        -----\n        Returns:\n        - (str): all positions and lengths of reverse palindrome\n    \"\"\"\n    len_lst = [12, 10, 8, 6, 4]\n    answer = \"\"\n    for i in range(len(seq_str)):\n        # print(i)\n        for length in len_lst:\n            if i + length &lt;= len(seq_str):\n                substr = seq_str[i:i+length]\n                if check_palindrome(substr):\n                    answer += str(i + 1) + \" \" + str(length) + \"\\n\"\n                    continue\n                continue\n    return answer\ndef check_palindrome(substr):\n    if len(substr) == 0:\n        return True\n    else:\n        if DNA_complementary(substr[0]) == substr[-1]:\n            # print(substr, substr[1:len(substr)-1])\n            return check_palindrome(substr[1:len(substr)-1])\n        else:\n            return False\n\n\nwith open(\"../data/rosalind/rosalind_repv.txt\", \"r\") as file:\n    text = \"\".join(file.read().split(\"\\n\"))\n    print(restriction_sites(text))\n\n1 4\n13 4\n22 8\n23 6\n24 4\n39 4\n57 4\n62 4\n63 4\n132 8\n133 6\n134 4\n141 4\n142 4\n175 4\n195 8\n196 6\n197 4\n200 4\n206 4\n218 4\n220 6\n221 8\n221 4\n222 6\n223 4\n225 4\n228 4\n234 4\n236 8\n237 6\n238 4\n261 6\n262 4\n271 4\n274 4\n307 4\n318 4\n341 4\n419 4\n442 6\n443 4\n461 12\n462 10\n463 8\n464 6\n465 4\n491 4\n520 4\n534 4\n544 6\n545 4\n548 6\n549 4\n609 4\n611 4\n631 6\n632 4\n639 6\n640 4\n652 4\n654 4\n703 10\n704 8\n705 6\n706 4\n715 6\n716 4\n731 10\n732 8\n733 6\n733 4\n734 4\n735 4\n758 4\n761 6\n762 4\n790 4\n800 4\n801 4\n822 8\n823 6\n824 4\n846 6\n847 4\n852 6\n853 4\n858 4\n886 4\n901 4\n929 4\n\n\n\n\n\n22 RNA Splicing\n\nimport re\nfrom utils import transcription, translation\ndef RNA_splicing(file) -&gt; str:\n    \"\"\"\n        The function returns a protein string resulting from transcribing and \n        translating the exons of a DNA string.\n        -----\n        Parameters:\n        - file: the file containing the string and its substrings (exons)\n        -----\n        Returns:\n        - (str): the protein string\n\n    \"\"\"\n    RNA_dict = {}\n    with open(file, \"r\") as f:\n        text = f.read().split(\"&gt;\")\n        final_rosalind = []\n        for rosalind in text:\n            if rosalind != \"\":\n                rosalind = rosalind.split(\"\\n\")[1:]\n                final_rosalind.append(\"\".join(rosalind))\n        for i in range(len(final_rosalind)):\n            RNA_dict[i] = final_rosalind[i]\n        pivot = RNA_dict[0]\n        for j in range(1, len(RNA_dict)):\n            pattern = re.compile(RNA_dict[j])\n            m = pattern.search(pivot)\n            if m != None:\n                pivot = pivot[:m.start()] + pivot[m.end():]\n        RNA_seq = transcription(pivot)\n    return translation(RNA_seq)\n\n\nwith open(\"../data/results/answer_rosalind_splc.txt\", \"w\") as f:\n    f.write(RNA_splicing(\"../data/rosalind/rosalind_splc.txt\"))\n\n\n\n23 Enumerating k-mers Lexicographically\n\nfrom typing import List\n\ndef k_mers_enumerate(seq_str: List, k: int)-&gt;str:\n    \"\"\"\n        This function returns all strings of length n that can be formed from \n        the alphabet given.\n        -----\n        Parameters:\n        - seq_str (List): a List of alphabet\n        - k (int): the length of the wanted strings\n        -----\n        Returns:\n        - (str): all the strings formed\n    \"\"\"\n    cur = \"\"\n    cur = recurse(\"\", seq_str, k)\n    return cur\ndef recurse(cur, lst, k):\n    answer = \"\"\n    if k == 0:\n        return cur + \"\\n\"\n    for j in range(len(lst)):\n        nextChar = lst[j]\n        pr = recurse(cur + nextChar, lst, k - 1)\n        answer += pr\n    return answer\n\n\nprint(k_mers_enumerate([\"A\", \"C\", \"G\", \"T\"], 2))\n\nAA\nAC\nAG\nAT\nCA\nCC\nCG\nCT\nGA\nGC\nGG\nGT\nTA\nTC\nTG\nTT\n\n\n\n\n\n24 Genome assembly shortest superstring\n\ndef overlap(seq_1, seq_2):\n    \"\"\"\n        This function computes the overlapping maxima of two given strings\n    \"\"\"\n    max_overlap = 0\n\n    min_len = min(len(seq_1), len(seq_2))\n    for i in range(1, min_len + 1):\n        if seq_1[-i:] == seq_2[:i]:\n            if i &gt; max_overlap:\n                max_overlap = i\n    \n    return max_overlap\n    \ndef genome_assembly(seqs)-&gt;str:\n    \"\"\"\n        This function uses greedy method to find and return the shortest s\n        uperstring containing all the given strings.\n        -----\n        Parameters:\n        - seqs: the list of DNA sequences\n        -----\n        Returns:\n        - (str): the superstring\n    \"\"\"\n    while len(seqs) &gt; 1:\n        max_overlap = 0\n        best_pair = (0, 0)\n        superstring = \"\"\n        for i in range(len(seqs)):\n            for j in range(len(seqs)):\n                if i != j:\n                    overlap_length = overlap(seqs[i], seqs[j])\n                    if overlap_length &gt; max_overlap:\n                        max_overlap = overlap_length\n                        best_pair = (i, j)\n                        superstring = seqs[i] + seqs[j][overlap_length:] \n        i, j = best_pair\n        seqs[i] = superstring\n        seqs.pop(j)\n\n    return seqs[0]\n\n\nwith open(\"../data/rosalind/rosalind_superstring.txt\", \"r\") as file:\n    text = file.read().split(\"&gt;\")\n    seqs = []\n    for seq in text[1:]:\n        seq = seq.split(\"\\n\")[1:]\n        seqs.append(\"\".join(seq))\n    print(genome_assembly(seqs))\n\nGGGTAGTCGCAGTTCTCGAGAGCGCCGGCACCCCGTGTGATTAGTTCCGCCCCGCGCTGCGCTCGAGAGAGTTGTCAGAAATAGAGCTGTGCAGCCCTGTTCCTTACAATTGTGTGCGCACGCGACTTGAAGTAGACCTTTCGCTGCTAACATGGCACGAAAGAAGGGTAATTGCAGCAGTGTATCGGACAGCAAGCGACCTTACTGGATGCAAGCGGGACCCCTGATAGAAGTTTCATGATGGGAACTTGGAGACGGAAGATCATTCTACGTTCGCAATGACAGGAAAAAGAATCGAACCGCTGAGCGCCTGCCTGGCTGTGTTCTGACAGGCGCACTACACCTGCGGTGTCATATCCTGCTTACTTCGGTTTCGCGCCGTTCTGAAAAGAATTCTAAGGGAATCCATCGTCCAGCTTGATGCTCCGATACAATAGCGCCCAAAAGTAGCTTAGCAGATCTCTCGTGCTTCTACATACTTTGAGAGGATGATGTTGTTCACCCCATCGCACAGTGATGTCGTATGTGCAGTCTTAGCGCGCGTTAGATCACGAGGTGGGTCAAGCAGAATATAATGGTACAGATGGGCTCAGCTTCAGTTTCGAGCATATGGCACGGATCTCGCACTCGGGGCGGTCCGTCCCACGGGTATTATCGTATAACACTGAGACTTTCCCTACCGAGAGAACAACTGGGAATCGACACTACTTGCGCCAAGGTAATTCATCACATAGTTACTGCGAACTCGAGGCGGTTGTCGGCAAAGGTTCACGAGAAAGCTCTGACTTCTTAGCAACGACCTGGCCGTACAGCCTGTAATAGAAGCGGTACTACTAACTAACACTTCGGGTCACATCAGGCACTTCACCACTAACGACCTAAACGTCATAGAATTTTCTGGATACGCCACCTCAACCGATCAAGGTATGCAGACAGAATGGCCAAAACAGGGCGCTGCGGACGTCGGGGGAAAGACTTACACTGATCGGCTCCTGCGTGCTTTCCGCTTACGACTTTGCAACACTCGACTTTGTAAAATACGCAGGTTTACGGATCTTTACGGTACTACAATGGATTTTTGAGGCAAAGACAGTACATATGAATGGGGAGCTTGCCGACCATCTATTGGAGCTACATTTGATGGTCGTACGCAATGGCCTGTCTTGAACGCTTGACGCTGATGGAGGACGACGCTCAGGGAGTTTGCTAGAAGGGGTCAACGCGACTCCAGAGAAGTTGGAACTATGGAACCCTTTTACCGTTCCCTGTAGCCGCAACGGAGCTTTATAGCCAGGCCGTTCAGCCTGGTCGATTTATGGGTGGAGCCCTTCGTTAGCGATCGCCACATACAGTACAGTATCAAGGATCATGTCACGGCTAATGGTCTGATAATCGGAGCTAGTAGTATCCAAGAGCGAAACGCGTACAAGACCCTGGTAGCAGTGCCTGACCTGTCCACTCAACGATGTTTGATAGGTTATGGTGGTGGGATGGCACGGCGTATAAACATGGCATAGTCACGTGTAGAGATGGAAACACTGCGGCGTACCCGACCACAGCGACCGAGCGCTGATGTGATCCTAGACCGTCCCATACCTGTGTTTGGCAGAACATTTGGGGTACTGAGACCCGTCCAACAGTTGCTCATCCATGTGATCGGTAAAGGCTTAGCCCATACGGTCACGGCTTAAGTATCAATGGTTTAAGTTTATGAAACTCAGGCTCGAGACTCTGTTTTTCATATATCTTCTGTTATCCTCTTGTTGGCGAGCATTCTCTTCTAGGAAACGAACAAAGAGAAACATCCACCTGGAGCATTCCTGAGGTGAGTTCGGGAAGCTCACGTCATAACGACGCGCTCTCAAAGCGATAGTAAAGCTAGTTTAAATTCCCATGCCTTAGTTAACCTTTGTCGTGTTCTGGTTATGTCGGGGAAAGAGTCAATGAATCACGGTTTGGATTGCTGTCGATCGTGATACGACTGCTAGGCGGTTAAGGGTTCTGGCAGATCGCTAAGTGCGCTTGAGTCTCGATGACAGTTTTTTAAGTTCACTCCGAACCGCTTCGGCTCTACCGATTCGAACCGTCAACCTCCTACGGGAGCTTAGGACCCCGTGGTCAGTCTTTGACTCAAGCTAATGGACCGAATCTAGTCGATCAGGCTCGCTCGATAGGTCGCTGCCCCTGACCACTGCGGAGGGACTTCGATAGGCCCTGACAGACCCGGAACGCCCAAGAGCGGATAAGTGCCTTGCGTGTCGGCTGGCAATAGTAGTGATTTAAAATATTCCAAGGCCTGCGCAAACCAGTGCTCATACACCCGGCGATAGCTGAGCCGGACCGCATACGTAGCCCTCTGTACAGCAAGGCTCCTCCCTCTGACCTTGCAGGTAAAAGACCGCCTACGTGGAAGTCATAGGCTCGACACGACCGAGAACCACGATTTGCGTACCGGCGTCCCGGTGGGGTCGAATGGTTGAGGGTCGATCCCCGCCCCTATTTGGAGTAGGCATTGTCCTAATACTGGAAGGTGGATGCCCAGACAAAGTACTAACACGCAACGCGGTTCTGCAGTTACTGCCCCCGTATTCAGCCAGCGTACTGCCCATATTGTTATGTGACGAGCTCGTCGGTCGTGCTGCTTGAATAGTCACTCGTCGATCGGCTGGGCTCTTAACTGGGGAATCGGTTCCACCGATTATACGAAAACTATTAAAGGCGGGTTAGATTTCCAGCTGATCTAGCCTGCTAGTTACAACCAACTCCTCAAAAACTAACGAACTGAACGATGGTTAGTACGTAAACGGTTAAGAGTTAGGGCTCGTCGGCGCTAATAGATGCACACATCATGGGCCACGCCCAGCCACTATACCCTCGAAAGGATAGGCGTCGGAGCTTCAGGTCGAAAAAATGGGCTACGTACTATGAGAGTTTCGGAATTGGAACGGAAGAAGCGCGCTATCTATTTGCGCCTCAGACTATCCAGGAATGATGAGCTACTTTAATTCGGTTAAAATCGTACGGAGCCATAGTCATATTAATCGGCCGTTCGAAACAAATGGGACAAAATACAGCTGCAGTGTGATCGAGAGGTAGATTCAGCGCCCCTCAGTGAAGTCGCGAAGGCACGATCGGACTAACAAGTTGTGCTGCCTCATGCTTTGTCATAGCCGATATTGCCCAACGAGGGATCTAAGGCTACAGACCTGGGGAATCGCCTGGCGACTGTTCAATTGCGTCTTTAGTGTGACGTCGACGTAAATGGAGATAGTATTTTTGCCAAGCCCTTCCGTGGCTCTCCCAATAAGATTAAAAACAGCAGGGCGTTTAGTGAATTCACTATGGGGAAGCGCCTCCGGTCTCAATTGTTTGAAAGCGCTCGGCCCTGGCATGCACTAGTCACGATGGCCGCCATTATCCACGCACCACTAAGGTCGAGCCTTAAGAGAGGGGAATGTCTAGATGGCCCTAGTATAACTGCTTTATTGCATTCTGAAAGCCCATTGTCTGTAGATTTAGCGCCAGCGATAGCTAAATAAACATCGTAGTGCGGGAATGCAATCCAGTTCAGCGTATGAACTTTAAATGAAGATGGACTTACAACACACACTGATGACGAAAGCCTGTAGAGTAAATAGAATGACAAAGTTAGTGCTATACGATCATTGCGGGGTTGGTGTGTCAATTCTGTGGCACCATCTATCGATGGTATTGGCTACTTTCGTAATCCTCGAGTACTGGGACAAACCAACAGAATCTCCTTCTCAACCCTAAGCAAACCCTACACGCGTTTCAGGGGGCCAACTGGAGTCGGCGGCGTAGTCCAGCCGACACCGCGCACCTTTGTGAGTACGCTAATTTGCTCTCATGGAAAGGGTCACTCTAACGCTCTGTGCAAAGCTTGCCCGTTGCATAAGAAGACCACCGTGTAGGTACTAGTCGAACTCACACTCACAAGTCAGAAAAGGGAACGCGGCGCGCACTTAGGGATCTCTCGCCGACAAATGGTGGTCATGGGCCTTGTGAAAATTTTTGTTCTTCAGAAGAGGATGGTTCTCGCCCGTTAGCCTTGGCTCACCAGTTCGTTTCTAGATAACATGATTTGGAGCGGTTTGTCTGAATTAAATCCTCCTTGGTCGAGATTGAACCTAGCGCTGGAACGAAGTGCATCGCGTCCATAACGCACGCACCGCTATGTACCGTTCTCAGCGGCATCACTAGGTGATAGACATTCGCTTTTAAGTCTTACGGCCTGACCGCTGAGGCTCTCAGGCGTGCGTCATAATCACGGTAGCTGCGAGCTTAACAATCGGGTCGTCCCAGGAATCGGTACTTCGTTATCGTCCACTCAGACCCTGCTTTTACACCGATTCGGATTCATACTTGTCTTTAGATAGCCACGTGAGGCTTCCTTCTGCCTTATTCGCCCTCTCCTTGTTGAGGCCTGTTCGCAAATTGCGATCATCACCTAACCCGTCCCCTTGTCCCCATACGCAGGCCACGGCGCAAATCACTTTGAGGGTTTTTCGTCGGAGAGTGATATGTCTTACAATGGGTGGGCCACCACCGAAAGAAAATACCTTACTCTATGGAACCATGTGCTAATCTTTCTCAACCGAATGCTCGTGGGGCGTAGCGGTTTGATCGTTACGCTTATGATACGGCACGTTTGCATACGTATTCTTGCTTAGGTATAGACTGCGTGCGCTCGATCGCGCACGAATGAAACTTCACCCCGAGCAATGCCTACTAATCTCTTGCGAAGTGTAAGACCAGCATCATCTTATGGTTTGTAGGGTTCGGAGGGCAGTCATACTATTGTCCTATGAATGAGGAGATTTGACAAGCCTTCCATTTAGTTACTGCGTCGGGCTGGGTTAAATGTCGCGCTTCCCAAAAAGAGGAAGTCGGGGATGTAGGCGGTTTAGCTGAGGGATATGAGGTGTAATAGATTGGCAGATCTTACTATGGCAGGGAAAAGTTGGGACATATTTGGAATCAAGTTTAGGTCTAGGTATGTTAGTCATACTCGGCTTCCATCTAACTAGAGCCATACATAGTCCATTTCTCGGGTGACTCGTCTTATTTCCCCAATTCTGTGCCCGGCAAGTGTTTCCGCTGTAGGAGTAATGCTGGTTCACGTTCAGGCCCTAGGCTGAAGCGTCTTCCGAAAGCCATCCGTCGACGAGTAATCTCCTGGGAGCGTGTTGGGGGCGCCTGCATGACTTTTTTACAGATCTCTCTCACGTTTAGGAAACGTATCGATCGGATCGAGTCTCCTGTCCTGAGCCAAAGCTACACTCTTACGATGGACGTATTCAATATCTGACATATCCTTGAGTAGCAATACATGGGAGTGTCAATTCGAGGCGTTCCTGGAAAACCGAGTTGCTCTTGAACGACGTCGGCGACGTCAGCAAGAAATAGCAAGTGCCGTCTGAATCGGAGTGTTCGCGCACAGTTCTGACACAACGTTGAATTTCAGTGACTCCAAACTCGCCTATGCTACGAGTTTGGAAGCAATCCGGATTGAATCATACTTCCTTCATGTCGCGCGGAATCGGGCTATACTGATTAGACACATCACCACGCCGACTAATAGGGGTCCACTGACTAGTTAAGGTGAGATGAGAGGTGAGATGCAGCCCGTGGACCAGTGGCTGTCTCATCCTGACTGTGTAGAACATTTAAAGAACCTCGGATAACCGGGAATGGACACAATAAGTTGAGACTAGCCCGCCGGGATATCACTCTAACGCGTCCCTCACCCAACAATGTAATATACACTTCACAATCAAAGATTTCGGAGCGCCACGGGCGTCACAGGGGCATGGGGATATACCGTTCGTGGACGTGCTAGTGTGTAGACGGCCATCCGTGTGTGCGGTGCGCGCATTAGAGATCCAGTTTGGGTAGCTTGAGATTATCACTGAACATCTTCAGTCCTTAGGCACCCATGTGAGGTATGAGTCTTCAGAGCATACGTATTCTGTGCTCACATGTTCCGCGGGGTCTAAAGCATTCTCAACTTTACGAGATCAAATTGCCTTTGTGGTCATTGGCCAGACCAAGTTCTACTTGGCTTCGTCAAGAGTTCCCGAAAAAACGCGATCCAAGCAGGACGAATTCAGGTATGAAGGAAACTGGTGGGCTACCATATCCCTAAGAGTATCCCTCGCCAGCCGGGCGATACTGTTGAAGTGTGATTTCAAGCAATACGGCGACGCAGAAATAATTAGAATCTGTTAGGGCTGGGGGGGATACTCCAAGTTCATATTGCATCAAGGAACAAGGCTAGCACCGATGGTATCCGTTTTGATTCTTCTGGCGGGTCAGATACGCGGTTTACGTATGGTCAATTGCCTCATGCATGGAGCCCAACGGTTATTGCACTCTCGCCGATACCCTCAGCATCCCTAGGATTGAAATACGCACGGAGCGTGAAACATTTGCAAAATCACCCCCTTAACCGTTAGCTGCCTATCAAGATTGCGAGCCTTAAGGGGCAGGTAAATTCCATGCGCGCGGTGACCCGGTCGCAAGTCCAAGCTCGGATCTACGGAGACTGTATGTGCAACACAATATTGATTCGAACGCGACGCTAAATTGTATACGCCACCCCCTTAACGCTAGGCGCTCGTACCTTATGATGCTCTGCACTTCTTCCTCACAAAACAAGTTATGTGAATGAGAGACCTTCTCATGAATCTGGAAAAACTTGTAAAGGTTCGCATATGCGTCGACTCACCCGAGAAGTGGGGATCAGTTGGAAATAGGTATGTCTTTAACCATATATGTACCTCCATTGCAGTCTGCTGCGCGGATTTATGCAGACATCCGCTAATCGGCACATTTCCGCGACAGCTATATGTAATCGTGGTTGATGCGTAAAACGCAGCGGAAGAATCGGATGATCTCACGTTTATATGTTAGGCCCGATTGTGGCGGATGAATGTCATCCCTTCTTGTCCTAAGAGATACAGTGCTCGCATGAAATTTACATGGTTTCCTGTCATTTTCCATATCGAATAATGCGAGCCTCTCGACTACAAATTACTAACGAGCGGGATGAGCGTCTCGTGTTTCATAGTCACTTCGATGGTGGTTATCGGCCGCCCCCGGAGGATTAGTGAGTAACTGAGATATTGTGCTTGGACATTGAGCAAATCTTTAAGGACGTAGTTGTCCGATCACGGGTGACGTGGGTGTCCTTTAGTCCTGACTTAGATGTTCTTGACTGCTTATTGATCTTCTACAGATCCGAAGCCATAGGGGGTTAGGTGTAACCGGCGGGGCTATCAGGACGCAGTACATTGATATGGATATCTTTGTCCCCGACGACTCGTGTCCTACCCGCATGGCTTGCCCGAATATGGTAACTCGGTACACAGCCCAAGGATAAATCTCATCCGCATCACAGACATGTAGTCGCCCGGGAGGTGGTCCTTGGTTCCGGGAAGTGAGACGGGCCGGGTTACGAGTGCTAATGCGGCTTGTGAAGTAGGTGTGTCATTCCTCCGGCATTATTCTAGCTGAGGAGTAGGATAGTCGTTTGGTGGGGAGATTTTTTTTGTTAACTCAGGGAGCTGAACAGCTGATGCCGTTCGCTACATACGCCGTTACCGCGAGGTTGTATCGGTGCCCCGGATCTGTGGGAAAGCTACTCTATCCCGGGCCCCCTTTAGGAGCTACAGCTGTTGTTGACTCTACAAATAGTAGCTTATCTTACTGCAGCATAAAACAGCTAATATTGCCAAAAGAGAGCTGCCCCAGGCGTTCGCCATGACCGTCGAAACTTACCCAATACCCTGTTTTAGCATTGGATAAGTCCAACACCCCAATTATCGAAAGGGATTACACTATGTAAGTAGGGACATATAACAGGTATGTTTCCTATGTTTCGGTATAGAGCGTTCCTCATCTCCCCTGACAATCGAACCGCGTCTAAAGTATCTGGGGTATGCGTTCTATCCTCCGTGTTTTCCCACCTTCAAGGTGTAAGATTAAAGAGGTTACTAGCAAACTATTTTGCACCACCTTGCCCAAGATAGTGACTTCCCGTAACATGCTAATGTTCCTGTCTTAGTCAAAGTTGGAGGTGGCCTGGTGTCAAAAGTATTCTCATTCATGAGCCCTAAAACGTCGTAACACCACTAGGCAATTGTCTCCTAACGAGTGTCTACGCAAGAACCTGCCACTAGGCCCCTCATGTCCTGCGAATCAAAAGTTACCAACCCAGGTTTGGAGTCGAAATAGGCCCCGCATTCCAATTGTTGCCGGCGTAGTCTGGGCAATTTATGTCGGTCACGTGTGTCGACTCTTTAGGACGAGATAAATCGTCGAAGACAGGGCATGTAAGCATACGTCTTATGGGAGGGTGTATATGGTTTATGCTAGTCCTTAGGGCAATCCCGGGCCGGCCCAAGTCAGCCCGTAGAAGGCGTGCTAGGTCGCGGTTACCCGTTCAAGCCATTCTACTGTAAGCCGCCGCACCGTTTCGTGGGTAGGGGAGACCCGAAATGGCACTGAGCTTCAGCAGTCCGTTCAGGTTTGACCGGGACCCCTTGCCGCTCGGCTTTTGGTCGACTGTTCGTGTGCCCATCAGACCGTACACGGCTGTAAGGAAAGGGGACTTTTCTACGCACAGGGAAAAACGAAGGGCATGTGTAGGTACACCCAGTATTTCTTGTAACCATGTTACGAACTCATGAAATGCCGACATAGCAGTCCAAGGTCTGATATGGTCCCACTTTAAAAAGGGTCAGTGATCTCAATGCTTTGCGTCACAGACGTTAGTATCCTTATCATGACGGGCGTGTGGAGTTTCGCCCAACATCGCGTATTTATAATGCCTTGGGTTGTGCGTTTAGCTAGAGGGGCCCTTATAACCTGGGTCCCCGGTTGCAACAGGAGAAAGATTACCCGAAAGGACTTAAGCTACGCCTGGACGATGAACACTCCGGGAATTACGTAGCCGACTGGGACTGTACCGTTACTGTTTCATAAATGGAATCGATATACAGATCGTTCCTAGTAACGGCCCCTAGTCCATTTAGAGTCCAGCCTTCCTACAAGCGGGCTCAGTACCCGATACAGCGGATAGAACCGTCCCGAGTGCACGTAACTCTCTGCCCGGAGGTTAGCCGCATCCGAGAAGCGTTTAGCTCCTTGCTTACCGAACCTAGACTCCGTTGACCAGCACTGAGTAGCGCATAACGCCTCGAGAAAGCTCCAAGTAGGTGAATTGAAGTCTACGTTGAGCTAATGGATTGGCGGCAAGCTACAGGTTTGATACGTTACAACTTTGGTGTTGACATAGGCAAGTCAAGTCCGACGGCATTTCCGAACCAGAACTTTCGAGCACTGTATTAAGGCATTCAATAAGTTGTAAGGGATCTCGGAAAAAGTGTTACGTTAGATCACTTGGACGGTGAACCATGAGATGCAGGCCTCGATCCCGGTTTTAAAACACTTCGAGTTCTGTGGGCCAATTGCCGGGGCCCACCCCGTCAGAAGGGATGGTCTTATTCTTTCATTAGAGCGAGGGAACTGTCGACTTCGAATGGTAAAGGTTTTGGAATTTATCATACGCAGCTATTACGCTTCTTCTCCCCGTGATCGCCACGATCTAAGCAGCGGCGGATGTAAACCGCGAAACCGGACTGATAACTAGCTGCCTACACGTCGGCGCTGCTCGCGATATGCGGAAGGGCTGTTCTCCTAAATTAGCGACGATACATCGTTGTGCAATTGGCTCCGCTTGGATACAACGGCTGAGTAGGGTGACTCTAATCCTAGCACGATAATTTCCTGGCTTGGACCTTTTTGTCACTTAACCGCACTATAGAGTTTTGGCCACCAACGTAGCTCGTGTATCGGGATAGCAATTCCGACGAGCGTCTCCACCTCCGGCAGGCGAGAGCGATTTGGAAACTAGGCTGGTTTATACCCCTGCAAATAATGGCCAGTAGCAAAAAACTCCGAAACGGGCAGAACTAACGTCCCAAATCCGGTTTACAATTAATCTCCAACGACGTTCCCTAAATAAACTCACTCTCGTTCAGTCTCCATATAGGGGTTGATACTTTTTGTCGGAAAGGACTCCTAGCCGTGACTAGGCATGGGAAAGGTGGGGCTGTGACCAGTACATTACTGACCTTTGCCTTGATTTAACGGGCCTTTTGGCCCCTAAAACAGCGACTCGCTAAAGGTTATTGGAATGCAAGACTTACACACTGTTCTCCATGGGCCGTGTTCGCACTACGTAAGTAGTGGTCTCATAACTCGGCCGATGTATCATAATCTTTCTCGACGGTCTACTGATTTGAGGGGTCCTCGGTTACTGCACGGCGTGGTGGCATTACTGACACGTTCTTAACCGAACGCGGAAGGTGCGATTAAAAGCAGGACGAAGATAATACCTTTGGGACCAGGCGTCGAGGTACGTTAATTCCCAGCTATTCGCGTTGGTCTTAAGTTGCGAGTTGTATGAATGAGAACTCTATGGCGGCGACAATTTCATATGCGAGCTAAACACCTCCCCTTACAAGCGAACGAGGGATAACTTCCAAGACAGATCGGCGGTGACTAGAGCTATGGACCCAAGGTACGCTTATAAGTCATTGCGGAATATCTCCCATCACACGGGCGAGCAGCGGAGAAGGGTTTATAGGACCCCCCGATCGGAAGTAACGCAGGAGTGACCAGTCACTCAAAAACTAATCTGGAGCCAATGTGTCCCTCCGCTAGCGTATGGATTGATAGTTTCCTGCTAATTAAGATCTATCAAAGGAAGACCTTTATCAAAAAATAAGGTGATTTGTTGCACGAAACATTGGATTGTGGCTGATGAGTCCAAAGATGAAGAATTTAACAACATTTACGACGGAAATCCCTTGGGTGGACCAAAGAATGCACATCCAGGTAACTCGATAAGCGACTATATACGGGTTTCGATGAGCGGACATTCCGGAAGGTGTCCAGTGTTGGAACGTTGCTTGAGTTTACAAAGCGCTCCATCAAGGCCAGTGTGTATGTTTACCCCACTTCCCACGCGGTGCTAAAACCACGTTAAGGTACGTGACTAGCTCCGGATCTATCACTAGAAAATAAAGGGGGTATCGTGGGAGTTAGACAGCCATCGGCCTATTCTGTATCCCGCTCAAGGTAGGCAAATCAGCATAATATACGCGTGTTATGCGGTGGTAAATGATGAAGTCACCTGAGAGTGATTCGGCACACCCGCCCTCGTGAAATGTCTCACGATGGTGGAGATTTCCAATGCATGGTCCAATGAGCTATATCGGGCCAACAGTAACTCGCGCTAAAACCCCCCAAACCCGTCGTATGCCAGTCGGTTACTATCAACTGGAATTCTGTTTTTTAGAGCGGTAGTCCTGGCCATGAAAACACTTTTGGGAGCTGACCTAACGTGTCAACCGTGGCCGGATTGGGGCCAGAAACAAAGCAGACTACCTAGTTGCATTATTTACCGCGAGATACAAGCGAGGTAGCGGCGACTCGATTTAATGGCAGCCTGTACAGATACACATCGGCATCTCTTTCCCCGCTGAGGTGAGCTGATCGCCGTACGACATAAACTAAAGGGCCACCTCTGCGGTATTAACATTATACTGCACGGCGTATACTGTATGTTGGTTCGATCCAAGCGTAAACATTCAACATCCGAATTAGGTCAGGGGTCCCACACACAACGGCAGAAGGTTAGCGCAGCGCGGGTCCTATGAAAGGACCAACTGGTTCCGTGCTAGGTGTGTCCGGGGTAATCTATGAGGCAGTGTGCTCACCTGAAGGTGCGTCAATCTGTCAGTCCGTGGTCGATCAACAGGTCCAATCAGCCTTGAAAGACACATGCATTTGGTCTCCTGTCATTCTGCTTACCTTACCTCTTGCCTAGTGTTGGGGCATGACGCCTGGAAACATACCTCTCCACGTTGTGTATAAAAGACCTCGCCATTCCTATTCTAACCCAGTTGGCTGGCTCATAGTGTCAAAGAAAATCCGAATCAAGGCGGCTTTATGCATCAGCAGTGGCACAGGCACTTCTGAAGTTGTGGGTAGGCTGCGGTCTCAGTTCTATTTTAATTTGCCGTACTAACTTTGTTACGTTACCTCGAGCACAATGGATGTACCGGATAGTTTGCGGCCCAGGTGCTAGGCGGACTTCAGCGCGGCTTCTACGGCAGTGGGTACGGAGAGTAGAGTATAGCCCGGGCATGGACTCCGAGTCGCCCAATGACGATGCTTCTCTTACCTCCGTCGTCAGCCACGTGATTAGTCCCTACCTTTGGTGTGGATGCGTCACCGTTCGCTGAGTCACGCGGAAGATGCGTTAAGCGGCTCCTCACATACAGTGGGCCAACCTTCAAGGACGAACGGCCCGCACTCCATACGGGAGGATATTAGCCACACTCCAAACGGCCTCATGCATATAGCATAGAGCCGCCACAAGCCATACCTAGAACATGAAATCCCAATACTGACAAATTTTCCGGTTGCGTACCAACAGGATGGCCGGATCCACAAACGGAGTCCGCGATTGACGGGGATTCGATTTCCGTGCATTTTAGACAAGGTGAGCGCGCCTCAGACCACAAGCAAGATGACCAGTCCATTAGCGCCAGACCTGCGGTACAGTCATATTTGGTCTATCGCAAGGGATCTCAAGGATAAGTGAGTTGCATTGTTTATTGCATTTTCTACCTGCCGGTAGATGCAATAGAATCGCCCTGCCGGTGGGCCCGTAGTCACGAAACTTCACTTTTGTGCCGTTCAGCTTCTGACGCACATTAGAACCCCAGGTACAGGCGACGCAGTCCATGTAACGAATTCAGCGAGGATCGGATCTGCTCAGTGCCCTTCTTTCGGGCTCGGTACAACGGAATTATCCGATGTACGATGGACAAGTGTTGTGACTGGGGTTCCACCGAAAATATAGGAATCGTGGTCACTACGCACTTGGTTTCGTGGAAATTTGCCCCTTTCACGGCGTTCCCCTCTTCAACCAGCGCGGGAGAAGGCACGTAAATTGAAAATCTGTTGAAGAAGCAAAGTCGGGAACTTTATCCGTAGTAAGCGAATGTTAATTTCCAGTCATCCGTAGATACGGTGCATGCAGAAGTATCAGAAAACACCTCGATAATACTCCCGAAAAGCGCATCAGGGCGCCGTTCCGAGGACTGCTTCAAGACATGTTACTTTGTCTCACTTGCGTTGGCAATAAGTCACCACCGCCGGTAATCGGTCTTTTGTGCCGAGGCTCGCTAGAAAGACCCTCGAGGGACCCCTATCAGAAAACAGGCGTTAAGACGCATCGTCTTTTAACGTTACACTATCAACGTACAGTTCTCTCGGCCCTGAATCGCCAGGTGTTAAAGAGTCTAGAATAGTCCGAAACACGCGACTCGCCTGCAGCTGTCGCTGGACGCTGGGGGGGATTGGTCACTTTGTAAGTGGATAACGTACCGGGATCGCAGGAGGGAACTCTCAGACCGGAAGCTCGCCGATACCGGCACTCGTAACGTAGATATTCAGGTGCTAGTTCTAAGGAAGGTAATCACCAGTGAGCGACATTACACTGGTGAGATTTAGCTTAGGGGCTACCTGGCGATAGTACGTGATATGGCTGGACCCAGAGACGTGTGACACTTTGCCTATATGCGACTATACCTTAGCAGTACCGGATAACCAAGGTTGCGTCAGCCGGCACATGAGATGGGTATCGCCATCGGCCGATTAGAATCAATATTACCCGCAGGAAACACGACGGCCCGTCGGCGGTAGGGTGACTGTGACGGGATGATATTCGTCTGAACTACGTCTTTGTGGTGTTCCCCGCTTTATGGTAACCAGCTCGCAACAATGAAGCAAGGATTACTAGGAACAATATATTACGGGAGCCGCCTCAATATAAAACTTTTGCATAACCCTTGACACGCAGTCCCCTTTAGCAGATTCTAGCGCACAGATGGAGTAGGGCGCGTAAGTCTCACCCTTGTAACCGGCAAGATGTTATTGCTCTGCTTATTGACGGGGCCTAGAATTTCACCTACTGTACTGTGGTTAGCCACGTTCCCTTGCAAGACTACCGCATCGGAAAGCTTACCCCTGCTAGTGAGGGGGCGGCATAGGCCGGAACAGATCCGGATCTTGTCGGGAAAAGAGGGGCCTGGAAGAAAGAGATCCAATAGTGCCAAAGCCTGCCCGTTGTAGTGGCGTGTGACGACTACTGCCACTTGGGCCTATCATGTCGCACCGTCCTCCTAAAAAGCGGGTGAGATTCTTTCCAGATACACGCGGAGATACGGCAACGGGTCTCGCGCGCGCATGAAGCAGCTTTACTAGACCCCACACTAGCCGCGGACGGCCGTCGTAGTAGAGTATGCTTCAACGGCGAATCAAGACAAAACCAAACGATGGTGCGGATCTGCCGAAGTGAGCGTACCCACGCAATGGCATATTGGGTATGTTGATTGGGTGGATTTACCGTCTTACCAATAAGGGGATTGCTAGACCTCTCTGGCTGAGGGGCATATGGTCCTCCGGTGTGTCCTTCTCCCATCGCACTACGGTTGCGGAGCGTCCTGCGTTCCACACCGTCTCCTAACGCGCCTAGTTTCACTTTCTTTTCACAAAACGGAACTGCGCAACGATGCTCGGCTGTATATTGAGTAGACTGACGACAGTACCGAGGAAAGGCTATGCTGCCCATTCCGGCCGACATTTCCGACTTGAATCATAATATACTCAGGTCGTCAGTCACGCTATGGATCTCGGGCGCCTTCGCACCTTGAAGCGCGAGTCGACAAGCTTATTGCGCTAGCCTCGAACCAGCTCAGTAGTTTAAATAAGGCTAGTATAGGATTGGCGTAGCCACAATTGAATAAGCTGCGCAGCATCTCCACGAGGTTGTTTGACAATGTTTTGCCTGGCTGTTCCTGAAAACGACTTTGAACTCTGTCCGTCACAACGTAGTAACACTTGTGCTTGTGGTATCCGCTCGGTGCCGAACCGACGTTTAACGTCCTTACCCGAACGTACGCGTTCCTGATTTGCAATATGCTTTCGCTCCCTTAGAAGCTAACCCTCACTCTGGTAGGAGTTAATCCCGGGGGTTTGGAATCTTCGTGAAAATAAACAAGTGGCAGTCAGAGTCAAATTGTCTGATGCTTGGTTGCACAGTGGTCTGAGAAGTCTGTAAAATATATCGCTGTCGGTATAGTTGACCGTAGCAGTAGGAAATCGACAAATGAGCCTTGAAATCGAGGGAACTTTTCGGACGCAAGAATTCTTCTGGCTGTGCGTTAACATTATACGGTCAAAGCGCATCTATCGTGTCTCTGGACTCTTAACTGCCCAGTTCAGCCCGCGCGTTTCCCCTTAACGTTGTGAAGCCTACGAACTTCGTAGCTAGCACCGGGTTCCCCGCTAACTTTCGTAGAATCTTTGCGTAGAAGATTCGAGAGGTGGGGAGCCTCGTACCCTGCCTTAGACGAATTTGTGCCTCTATGGGCGTTATTCAATAGTCCACCGACCGGTACTGCAAGCGGAATTTTCTCGTGCGACCACGCTGCTTTCAGGCACGGAACAGGTAGTTGTGGGTGACTCCACGCAGTGGCCGCGAGCGCCTCGTTCGAAATAAGGATACCGGTACAGATGGGTGCGCGCTTTGGGTGGTACTAATAAACTATTACCACTAGCGCGTCCCGCTTACCGTGAAGGTAGGTCAGTTTTTTAGATATGAAAGCGGGTGCGCTTCTACGACGCCGGGAGGAGCCCGTCGTCATTTGATTAAGCGAGAAGCGATCATGTGTCATCCCTTAAACCTATCATTATGGCACTCCGTTCAGTCAGCAGCGTCTTGAGTACGACAGACCACTAATGTCAGTATTTTCTCAGTTCACAGCAGGCGGTCGGATGCACGTTTACTTGGCCTCTACACCCGAGAACGTAAATTGTCATTCGAGCTGATCCTATCTCGGAACTAATTAAGAGATATCTAAAGGGTCCAGATTGATCGTTCGTTGTCGCTAGGACGCGTCATCAAGCACGGTGTTGTGCAAAGAAGCTCACAGGGTACAAAACTCGTTGGAATACGGAAAATCTAATACTCGATAACGTCGGTCGGCCCATAGCGCGAAGAGGTGTAGCATCCTGATTCGTTACGGATGACCGACGGAGTCCCGCCTGTTACATCTTCTCTATGCAACCTCTCAGATGGACCATTTCGTCCTTCAATTATTGTACTGGCGCGTTAACTGACTCGATCCGCCTCCGTACCCCGCTTGCGGCCAGCTTAGAGTTGACTTTGACAGGGGTGCGATTTCCCTGCCAAAAGTAATAACCATGAATTTGGCGCGCTCACCTTGAGCTCCGCAAGCTTGTCCGCGGCGCAGTCGGGAAGGAGGTCTTGGCAAGTAATTTCTTGGTGACGAACTCCTACGCAAGAAGTTACTCTTTCTATTTGAGGCGTTCGAAGTATGGTATTTCCCAGTTCCCACTACAACTACGAGAGCCTGTATAATCCAGTCATGTAGCCGTTTACTTCGCGTATGGAGCATAATCCTAATCAGGTCTTTAATCACCTTCATGGCGCAGCCCCCGCAACACTCGTTACAGGAGATGGCCTGTAGGTCTTGTAAATTTCTATATAGCCATTGACCGTCCCGAAGCAAACCAACCACGTCAAAAATTTCGGGCCACATCCCGATGCCGGCTGGCCGGAGTAGCCTAGGTAAAAAGGACGACCGCTGCTGAGGTCACTAAAGTCAGAAATAATATTGTGCAGGGTAATTGACGCATTCTCGTATTATTTCCATTATCAACGGACTCTACCTCGCTCCCGACCTAGGCTTTTGCCTATGCGACTATGGCGGAGCACTGGGCACTCATGGCGTACCGTGCCCTCCCTAACTCGCAAACGTTTGCGGTATGGTCACGACTATGACTGATTCAAAAATGGGTAGCGCGTGGTATTGTAGTAGAGGAAGGCAGTTAGATTGGGTCATGCCTATTAGATATTAGATTAATGACGGATCGTAGTTCAGGCGGTGCAGGGGAAGCTTATCCATGCGGGGTGAGATAGCACGACTCCGACGCCCCGGCCGCTAGCACCTCTTTTTATTTACGCTTACTACTCTGTTAGGATCAACTAGATTTCAACTACCAAGACCTCGGTCGCCATTAATTTTGTAACTTCTGCTATCTATCTTCCAACTTTCACTAACTATCGTGCGAAAGGATGGTCGATTTGTGCGATGGAAATTGGTCCAGCCGTATCTGCGGAGCCTGTATCGGGACTTTAGCGAGACTATTATCGAGTGATCAGGGCTTTCCCGCTATGAAAAAGTAACGTTTGCACTGCGCTGGTACGATATCGGCTAAGATTGCGTTGACAGTCATCGGAAGTCAAAAGGTGGCCTAATTACCGCTTTTTATTGCTGCATGTGTTTGTACCTATCTCCACCCGCCCAATTCTAGAACCAACGTAACAAAAGGTCAGGGGCAGAACTTCCGCTCCCTTCGACCAGTGGTCCCGACATGTCCAGGACGGTAAGCCCCAAGAATCCACGGAGCTATCAAATCCAGGGAAGGATCTGTGCTCACTGCTAGAGTTGTACATGCTACGAGCCGTGCGCCTCCAATTGTTTCTCCGTTGAGCCGAAGCTACTGGTATATACCCACCCATTAGTTTGTCTCTGACTACCAGTTACATGAATTCGACAAGCTACAGGTCAACCGACAGGTGCGGGTCAAACCGAACAGTACGACATACTGTACCCGGCTACCGATCGAGTGGGCCCGGGATGAGTTCCTCCGCCTGGCTGCGGTATGCCTTTATATCAAGAACCTAAATGTGCAAGTATATGACCACATATTCTTAGGTAGTTTTCCTGGGCTGAATCCCGCATTCAGCCCCGGCATCTGCAATTGAGCTAGGAGCCGGCCGCATGTCCTTTCCCTCGTCCGCCGGCCTTAGCGTAGCTTTTCGTAGCATCCACACCATAGCCCTGTGTTGTAACTTCGGGTCTGAGATCACCTTCTGTCCCCGAGAGGACACGTTCGGGAATCCATTCATAACTCGGGGAACCCGGCCACAATCATTCGATGAGGAGCCATGATAGGGTATGCGTACGCCGAGGAGGGTCAGCTGTTACTCCCGCGATCATAGGCCCGTATGTCGACCTTATTCTACACGAATGGCGTCAGCGCCGCGGCGCCCTAATCTAAGCTGATCCCGGTACAAGGATTCACATTAGCGACGTAGATCCGGAACGGAAACTTGTGGCAAGGCTTAAAATCCTGCACAACTCCGGGACCAGAGGCTAACTCATCAAAGGAATGACTGTAGATTAGCGAATATAACAAGCTAGCTCGTCCTCCAGGTCAACTTGGAGAGGGGGCGAGCACCGATATGTTAACCAGTGATCCGGCGCATTAATATCCGGATTCTGTAGGCATATTCCGGTGGGCTCCTCTATAACTTTTAATGTCATGGGGCATTTATAGCATGATCAAATTACAAGCCTAAATGAGACAGAACCCCCCTGAGGTAAACAGCATGCAAAGGCACAGCAGGGAACTACACTTAGTCCGCTGCCTGTGGGCATTATCGTCAATTTAAATGTGTTATCCGGGTTTTCTAAGACACTTAGCCGCCACGTGAGGCGTCCGGAGACAGCCTAACCGGTAAATGGTAACGCACACCTGATCGAATGCAATCTTCAGTCGACTTTTACCTCTAGGTGCTACGGGGATATGTTAACGTTGCTGATAGCCTAGCCTAAACTTGCGTGCGAGAGTGCGATCATCTGTTAAAGGGTTGGAGGATAGATAGTACGCTACGAAGTCGTTTGTTATTACATTGATGGATCAGTGTTGCGAAGCTTTGTTGATGACAACAAGATACGCGGCTTAAAACGATAAAATTTGTGCTCGGCCATGTGA\n\n\n\n\n25 Perfect Matchings\n\nimport math\ndef perfect_matching(seq: str) -&gt; int:\n    \"\"\"\n        This function calculates the total possible number of perfect matchings \n        of basepair edges in the bonding graph.\n        -----\n        Parameters:\n        - seq (str): the sequence to form the bonding graph\n        -----\n        Returns:\n        - (int): the possible number of perfect matchings\n    \"\"\"\n    A_counts = 0\n    G_counts = 0\n    for char in seq:\n        if char == \"A\":\n            A_counts += 1\n        elif char == \"G\":\n            G_counts += 1\n\n    return math.factorial(A_counts) * math.factorial(G_counts)\n\n\nwith open(\"../data/rosalind/rosalind_pmch.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[1:]\n    text = \"\".join(text)\n    print(perfect_matching(text))\n\n778817392288148379660189696000000\n\n\n\n\n26 Introduction to Random Strings\n\nimport math\n\ndef random_strings(seq, prob_seqs) -&gt; str:\n    \"\"\"\n        This function computes the possibility of forming the given DNA sequence\n        using an array of GC-content probability.\n        -----\n        Parameters:\n        - seq (str): the DNA string to form\n        - prob_seqs (List): the list of probability\n        -----\n        Returns:\n        - (str): a string of calculated common logarithm \n    \"\"\"\n    answer = \"\"\n    for prob in prob_seqs:\n        prob = float(prob)\n        gc_prob = prob/2\n        qa_prob = (1-prob)/2\n        multi = 1\n        for char in seq:\n            if char == \"G\" or char == \"C\":\n                multi *= gc_prob\n            else:\n                multi *= qa_prob\n        common_prob = round(math.log(multi, 10), 3)\n        answer += str(common_prob) + \" \"\n    return answer\n\n\nprint(random_strings(\"ACGATACAA\" , [0.129, 0.287, 0.423, 0.476, 0.641, 0.742, 0.783]))\n\n-5.737 -5.217 -5.263 -5.36 -5.958 -6.628 -7.009 \n\n\n\n\n27 Finding a Spliced Motif\n\ndef spliced_motif(s_seq, t_seq)-&gt;str:\n    \"\"\"\n        This function returns a collection of indices of subsequence locations\n        -----\n        Parameters:\n        - s_seq (str): the DNA string\n        - t_seq (str): the subsequence to be found\n        -----\n        Returns:\n        - (str): a string of subsequence locations\n    \"\"\"\n    locations = \"\"\n    prev = 1\n    for i in t_seq:\n        pattern = re.compile(i)\n        m = pattern.search(s_seq)\n        locations += str(prev + m.start()) + \" \"\n        prev += m.start() + 1\n        s_seq = s_seq[m.start() + 1:]\n    \n    return locations\n\n\nwith open(\"../data/rosalind/rosalind_sseq.txt\", \"r\") as f:\n    text = f.read().split(\"&gt;\")[1:]\n    seq_1 = \"\".join(text[0].split(\"\\n\")[1:])\n    seq_2 = \"\".join(text[-1].split(\"\\n\")[1:])\n    print(spliced_motif(seq_1, seq_2))\n\n1 3 4 11 22 29 32 34 35 41 53 54 56 59 61 66 68 77 79 86 92 102 120 121 122 127 129 135 139 143 149 163 174 175 176 180 185 187 188 189 192 197 202 206 207 215 217 219 222 223 226 227 230 231 239 248 252 256 257 265 266 272 274 282 288 289 292 \n\n\n\n\n28 Transitions and Tranversions\n\ndef trans(seq_1, seq_2)-&gt;float:\n    \"\"\"\n        This function calculates the transition/transversion ratio \n        -----\n        Parameters:\n        - seq_1, seq_2 (str): the 2 sequences to calculate transition/transversion\n        -----\n        Returns:\n        - (float): R(s1/s2) ratio\n    \"\"\"\n    transition_r = 0\n    transversion_r = 0\n    nucleotides = {\"A\": \"purine\", \"G\" : \"purine\", \"T\" : \"pyrimidine\", \"C\" : \"pyrimidine\"}\n\n    for i, j in zip(seq_1, seq_2):\n        if nucleotides[i] == nucleotides[j] and i != j:\n            transition_r += 1\n        elif nucleotides[i] != nucleotides[j] and i != j:\n            transversion_r += 1\n\n    return transition_r/transversion_r\n\n\nwith open(\"../data/rosalind/rosalind_tran.txt\", \"r\") as file:\n    text = file.read().split(\"&gt;\")[1:]\n    seq_1 = \"\".join(text[0].split(\"\\n\")[1:])\n    seq_2 = \"\".join(text[-1].split(\"\\n\")[1:])\n    print(trans(seq_1, seq_2))\n\n1.797979797979798\n\n\n\n\n29 Completing a Tree\n\nfrom typing import List\ndef tree_build(num_nodes: int, adj_ls: List) -&gt; int:\n    \"\"\"\n        This function returns minimum number of edges that can be added to the \n        graph to produce a tree.\n        -----\n        Parameters:\n        - num_nodes (int): the number of tree nodes\n        - adj_ls: the list of currently adjacent nodes\n        -----\n        Returns:\n        - (int): the missing edges to complete the tree\n    \"\"\"\n    present_nodes = 0\n    dis_graphs = []\n\n    ## Stop when you can not add another graphs to the current disgraphs\n    while len(adj_ls) &gt; 0:\n        dis_gr = adj_ls[0]\n        isAdded = True\n        if len(adj_ls) == 1:\n            dis_graphs.append(dis_gr)\n            break\n        elif len(adj_ls) &gt; 1:\n            adj_ls = adj_ls[1:]\n\n        while isAdded:\n            # print(dis_gr)\n            addition = 0\n            for i in range(len(adj_ls)):\n                ls = adj_ls[i]\n                intersectionality = list(set(dis_gr).intersection(ls))\n                if len(intersectionality) &gt; 0:\n                    dis_gr = list(set(dis_gr).union(set(ls)))\n                    adj_ls.pop(i)\n                    addition += 1\n                    break\n            if addition == 0:\n                isAdded = False\n                break\n        dis_graphs.append(dis_gr)\n\n    with open(\"../data/results/results_tree.txt\", \"w\") as file:\n        for each in dis_graphs:\n            file.write(str(each) + \"\\n\")\n    for graphs in dis_graphs:\n        present_nodes += len(graphs)\n    return len(dis_graphs) - 1 + (num_nodes - present_nodes)\n\n\nwith open(\"../data/rosalind/rosalind_tree.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    num_nodes = int(text[0])\n    adj_ls = [list(text.split(\" \")) for text in text[1:]]\n\n    print(tree_build(num_nodes, adj_ls))\n\n23\n\n\n\n\n30 Longest Increase Subsequence\n\nfrom typing import List\nimport copy\ndef subsequence(seq: List):\n    \"\"\"\n        This function returns the longest increasing subsequence and the longest\n        decreasing subsequence.\n        -----\n        Parameters:\n        - seq (List): the sequences of numbers\n        -----\n        Returns:\n        - (str): the longest increasing/decreasing subsequence\n.\n    \"\"\"\n    seq_length = len(seq)\n    increase = []\n    decrease = []\n\n    ## Add 1 to all arrays\n    for i in range(seq_length):\n        increase.append(1)\n        decrease.append(1)\n        seq[i] = int(seq[i])\n\n    ## Construct an array to store longest subsequence increasingly and decreasingly\n    for i in range(1, seq_length):\n        for j in range(i):\n            if seq[j] &lt; seq[i] and increase[i] &lt;= increase[j]:\n                increase[i] = increase[j] + 1\n\n    reverse_seq = seq\n    for i in range(1, seq_length):\n        for j in range(i):\n            if reverse_seq[i] &lt; reverse_seq[j] and decrease[i] &lt;= decrease[j]:\n                decrease[i] = decrease[j] + 1\n\n    ## Iterate through the array to find the maximum value of sequence\n    max_seq = 0\n    index_seq = 0\n    max_reverse_seq = 0\n    index_reverse_seq = 0\n    for i in range(seq_length):\n        if increase[i] &gt; max_seq:\n            max_seq = increase[i]\n            index_seq = i\n        if decrease[i] &gt; max_reverse_seq:\n            max_reverse_seq = decrease[i]\n            index_reverse_seq = i\n\n    ## Backtracking from the maximum value max, if meets max-1, add to list array[max-1]\n    ## and assign max = max - 1, continue to track from backward \n    longest_increase_seq = [seq[index_seq]]\n    longest_decrease_seq = [reverse_seq[index_reverse_seq]]\n\n    for i in range(index_seq - 1, -1, -1):\n        if max_seq == -1:\n            break\n        if increase[i] == max_seq - 1 and longest_increase_seq[-1] &gt; seq[i]:\n            longest_increase_seq.append(seq[i])\n            max_seq = max_seq - 1\n\n    for i in range(index_reverse_seq - 1, -1, -1):\n        if max_reverse_seq == -1:\n            break\n        if decrease[i] == max_reverse_seq - 1 and longest_decrease_seq[-1] &lt; reverse_seq[i]:\n            longest_decrease_seq.append(reverse_seq[i])\n            max_reverse_seq = max_reverse_seq - 1\n\n    with open(\"../data/results/results_lgis.txt\", \"w\") as f:\n        inc = \"\"\n        dec = \"\"\n        for item in longest_increase_seq[::-1]:\n            inc += str(item) + \" \"\n        for item in longest_decrease_seq[::-1]:\n            dec += str(item) + \" \"\n        print(inc)\n        f.write(inc)\n        print(\"\\n\")\n        f.write(\"\\n\")\n        print(dec)\n        f.write(dec)\n\n\nwith open(\"../data/rosalind/rosalind_lgis.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[1]\n    text = text.split(\" \")\n    subsequence(text)\n\n85 164 237 352 472 521 577 608 641 661 852 931 1011 1074 1111 1128 1281 1301 1390 1408 1458 1641 1722 1749 1800 1946 1995 1999 2014 2076 2106 2115 2152 2194 2224 2305 2324 2343 2369 2379 2384 2471 2493 2525 2621 2651 2669 2670 2733 2790 2795 2839 2890 2945 3190 3210 3455 3457 3469 3470 3513 3649 3702 3739 3750 3856 3876 4035 4051 4056 4103 4115 4132 4140 4156 4326 4538 4570 4580 4616 4666 4669 4876 4885 4888 4935 5016 5261 5377 5389 5415 5464 5541 5583 5596 5902 5917 5929 5939 5941 6011 6089 6173 6186 6226 6244 6254 6319 6326 6489 6511 6607 6708 6843 6862 6891 6937 6964 7004 7144 7145 7240 7245 7383 7387 7429 7459 7624 7665 7675 7726 7791 7804 7844 7850 7865 7870 7888 7893 7964 7999 8048 8073 8087 8092 8099 8125 8135 8199 8221 8237 8330 8349 8395 8593 8602 8693 8731 8764 8772 8900 8939 9051 9142 9147 9198 9231 9248 9261 9323 9327 9333 9385 9389 9421 9428 9517 9565 9582 9674 9707 9775 9816 \n\n\n9811 9792 9779 9760 9717 9681 9678 9675 9479 9450 9395 9357 9342 9293 9262 9210 9160 9153 9101 8969 8956 8945 8863 8856 8819 8806 8770 8761 8677 8609 8499 8405 8391 8380 8294 8270 8191 8137 8105 8100 8074 8071 7983 7969 7954 7936 7856 7811 7790 7744 7731 7718 7685 7372 7290 7212 7184 7152 7140 7075 7057 7043 7005 7000 6866 6781 6712 6682 6433 6375 6358 6297 6271 6145 5995 5992 5927 5882 5795 5766 5751 5659 5656 5596 5549 5542 5462 5457 5422 5412 5393 5313 5179 5099 5057 5020 4988 4906 4856 4774 4714 4560 4533 4506 4418 4410 4382 4258 4247 4208 4128 4086 4014 3992 3969 3896 3806 3661 3614 3514 3360 3358 3335 3284 3149 3095 2976 2949 2887 2832 2753 2741 2732 2722 2632 2599 2590 2517 2512 2338 2296 2291 2253 2208 2188 2164 2021 1922 1911 1903 1857 1851 1849 1723 1714 1646 1610 1585 1582 1540 1514 1497 1483 1428 1379 1325 1207 1136 1135 1052 995 948 805 751 685 520 466 429 408 396 361 247 234 227 215 139 114 61",
    "crumbs": [
      "Rosalind",
      "21-30"
    ]
  },
  {
    "objectID": "rosalind_markdowns/41_50.html",
    "href": "rosalind_markdowns/41_50.html",
    "title": "41-50",
    "section": "",
    "text": "41 Creating a Distance Matrix\n\nfrom typing import List\nfrom utils import point_mutations\nimport numpy as np\ndef distance_matrix(seqs: List):\n    \"\"\"\n        This function creates the matrix corresponding to the p-distance on the \n        given strings.\n        -----\n        Parameters:\n        - seqs (List): a list of sequences\n        -----\n        Returns:\n        - the distance matrix\n    \"\"\"\n    seq_length = len(seqs[0])\n    distance_matrix = np.zeros((len(seqs), len(seqs)))\n    for i, seq_1 in enumerate(seqs):\n        for j, seq_2 in enumerate(seqs):\n            if i == j:\n                distance = 0\n                distance_matrix[i][j] = 0.0\n            else:\n                distance = point_mutations(seq_1, seq_2)\n                distance_matrix[i][j] = round(distance/seq_length, 3)\n    return distance_matrix\n\n\nwith open(\"../data/rosalind/rosalind_pdst.txt\", \"r\") as file:\n    text = file.read().split(\"&gt;\")[1:]\n    seqs = []\n    for seq in text:\n        seq = seq.split(\"\\n\")[1:]\n        seq = \"\".join(seq)\n        seqs.append(seq)\n    print(distance_matrix(seqs))\n\n[[0.    0.481 0.587 0.458 0.489 0.46  0.298 0.326]\n [0.481 0.    0.582 0.632 0.458 0.617 0.582 0.324]\n [0.587 0.582 0.    0.675 0.304 0.666 0.635 0.471]\n [0.458 0.632 0.675 0.    0.625 0.479 0.303 0.553]\n [0.489 0.458 0.304 0.625 0.    0.615 0.581 0.289]\n [0.46  0.617 0.666 0.479 0.615 0.    0.323 0.567]\n [0.298 0.582 0.635 0.303 0.581 0.323 0.    0.478]\n [0.326 0.324 0.471 0.553 0.289 0.567 0.478 0.   ]]\n\n\n\n\n42 Matching a Spectrum to a Protein\n\nfrom utils import comparing_spectra, get_mass\n\ndef spectrum_to_protein(seqs, lst):\n    \"\"\"\n        This function calculates the maximum multiplicity and its string\n        -----\n        Parameters:\n        - seqs (List): the list of protein sequences\n        - lst (List): the list of protein complete spectrum\n        -----\n        Returns:\n        - max_multi (int): the maximum multiplicity\n        - max_seq (int): the sequence corresponding to that maximum \n    \"\"\"\n    mass_dict = get_mass(\"../data/ref/mass.txt\")\n    max_multi = -1\n    max_seq = \"\"\n    for seq in seqs:\n        multiset_lst = []\n        for i in range(1, len(seq)):\n            pr_sum = 0\n            su_sum = 0\n            prefix = seq[:i]\n            suffix = seq[i:]\n            for each in prefix:\n                pr_sum += float(mass_dict[each])\n            for each in suffix:\n                su_sum += float(mass_dict[each])\n            multiset_lst.append(round(pr_sum, 3))\n            multiset_lst.append(round(su_sum, 3))\n        max_value, _ = comparing_spectra(multiset_lst, lst)\n        if max_value &gt;= max_multi:\n            max_multi = max_value\n            max_seq = seq\n    return max_multi, max_seq\n\n\nwith open(\"../data/rosalind/rosalind_prsm.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")[:-1]\n    n = int(text[0])\n    seq_ls = text[1:n+1]\n    lst = text[n+1:]\n    print(spectrum_to_protein(seq_ls, lst))\n\n(26, 'SPLNWRPWFRSWQWPIWPMPQMMMNGMSIFDRKQNPVQWLSRCVFERMMKFYWQCFQGFCFNKCYYKAHHFPYSEIGEHQEVPLMHNTTSTPGWKDRQMITEWQQLEQSAVIMFNYEL')\n\n\n\n\n43 Matching Random Motifs\n\ndef random_motifs(N: int, x: float, s: str)-&gt;float:\n    \"\"\"\n        This function computes the probability that at least 1 of N random DNA \n        strings having the same length equals to s\n        -----\n        Parameters:\n        - N (int): the total random DNA strings\n        - x (float): the GC-content prob\n        - s (str): the string to search for\n        -----\n        Returns:\n        - (float): the probability that at least 1/N string equals s\n    \"\"\"\n    P = 1.0\n    for char in s:\n        if char in 'AT':\n            P *= (1 - x)/2\n        elif char in 'GC':\n            P *= x/2\n    prob = 1 - (1 - P)**N\n    return prob\n\n\nprint(random_motifs(82568, 0.539812, \"AGCTTGCC\"))\n\n0.7632541926190596\n\n\n\n\n44 Interleaving two Motifs\n\ndef interleaving_two_motifs(seq_1, seq_2)-&gt;str:\n    \"\"\"\n        This function computes the shortest common supersequence between 2 strings\n        -----\n        Parameters:\n        - seq_1, seq_2 (str): 2 DNA strings\n        -----\n        Returns: \n        - (str): the shortest common supersequence\n    \"\"\"\n    seq_len_1 = len(seq_1)\n    seq_len_2 = len(seq_2)\n    scs = []\n    mat = [[0] * (seq_len_2 + 1) for _ in range(seq_len_1 + 1)]\n    \n    for i in range(1, seq_len_1 + 1):\n        for j in range(1, seq_len_2 + 1):\n            if seq_1[i - 1] == seq_2[j - 1]:\n                mat[i][j] = mat[i - 1][j - 1] + 1\n            else:\n                mat[i][j] = max(mat[i - 1][j], mat[i][j - 1])\n    \n    i, j = seq_len_1, seq_len_2\n    while i &gt; 0 and j &gt; 0:\n        if seq_1[i - 1] == seq_2[j - 1]:\n            scs.append(seq_1[i - 1])\n            i -= 1\n            j -= 1\n        elif mat[i - 1][j] &gt;= mat[i][j - 1]:\n            scs.append(seq_1[i - 1])\n            i -= 1\n        else:\n            scs.append(seq_2[j - 1])\n            j -= 1\n\n    while i &gt; 0:\n        scs.append(seq_1[i - 1])\n        i -= 1\n    while j &gt; 0:\n        scs.append(seq_2[j - 1])\n        j -= 1\n\n    return ''.join(scs[::-1])\n\n\nwith open(\"../data/rosalind/rosalind_scsp.txt\", \"r\") as f:\n    text = f.read().split(\"\\n\")\n    print(interleaving_two_motifs(text[0], text[1]))\n\nAGCAGAGGGAATGAGCCCAATCCCGAATGCGGGGCCGCAAGGTGAGATACAGTTAAACCTTGAGGCTGAGTTCCTTGATAAAATAAGCCACGTCATAATCGGATTTCGATAGCGGTCAGTGAAATAACTTTGTCG\n\n\n\n\n45 Introduction to Alternative Splicing\n\ndef alternative_splicing(n: int, k:int)-&gt;int:\n    \"\"\"\n        This function uses Pascal's triangle to compute the combination statistics\n        -----\n        Parameters:\n        - n (int): the total objects to take \n        - k (int): the minium objects to draw on\n        -----\n        Returns:\n        - (int): sum of combinations\n    \"\"\"\n    pascal_triangle = [[1], [1, 1]]\n    sum = 0\n    index = 2\n    for i in range(2, n + 1):\n        row = []\n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                row.append(pascal_triangle[index-1][j-1] + pascal_triangle[index-1][j])\n        pascal_triangle.append(row)\n        if len(pascal_triangle) == 10:\n            pascal_triangle = pascal_triangle[1:]\n        else:\n            index += 1\n    result = pascal_triangle[-1]\n    for i in range(k, len(result)):\n        sum += result[i] \n\n    return sum % 1000000\n\n\nprint(alternative_splicing(1649, 1238))\n\n725808\n\n\n\n\n46 Introduction to Set Operations\n\ndef set_operations(n: int, set_1, set_2)-&gt;str:\n    \"\"\"\n        This function returns all set operations between 2 sets\n        -----\n        Parameters:\n        - n (int): maximum of the full sequences {1, ..., n}\n        - set_1, set_2 (set): the 2 sets\n        -----\n        Returns:\n        - (str): the results of set operations\n    \"\"\"\n    ans = \"\"\n    full_set = set()\n    for value in range(int(n)):\n        full_set.add(value+1)\n\n    ## Convert the strings to sets\n    seq_1 = set_1.strip(\"{}\")\n    seq_2 = set_2.strip(\"{}\")\n    seq_1 = seq_1.split(\",\")\n    seq_2 = seq_2.split(\", \")\n\n    set_1 = {int(element) for element in seq_1}\n    set_2 = {int(element) for element in seq_2}\n\n    ans += str(set_1.union(set_2)) + \"\\n\"\n    ans += str(set_1.intersection(set_2)) + \"\\n\"\n    ans += str(set_1 - set_2) + \"\\n\"\n    ans += str(set_2 - set_1) + \"\\n\"\n    ans += str(full_set - set_1) + \"\\n\"\n    ans += str(full_set - set_2) + \"\\n\"\n    \n    with open(\"../data/results/results_seto.txt\", \"w\") as f:\n        f.write(ans)\n\n\nwith open(\"../data/rosalind/rosalind_seto.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    n = text[0]\n    set_1 = text[1]\n    set_2 = text[2]\n    set_operations(n, set_1, set_2)\n\n\n\n47 Expected Number of Restriction Sites\n\ndef expected_restriction(n:int, substr:str, arr)-&gt;List:\n    \"\"\"\n        This function returns an array represents the expected number of times \n        that s will appear as a substring of a random DNA string.\n        -----\n        Parameters:\n        - n (int): length of random DNA string\n        - substr (str): the substring to find\n        - arr (array): an array of GC-content probability\n        -----\n        Returns:\n        - (List): a list of expected restriction sites\n    \"\"\"\n    str_len = len(substr)\n    n_select = n - str_len + 1\n    expected = []\n\n    for gc_content in arr:\n        GC_prob = gc_content / 2\n        AT_prob = 0.5 - GC_prob\n        prob = 1.0\n        for char in substr:\n            if char in \"GC\":\n                prob *= GC_prob\n            elif char in \"AT\":\n                prob *= AT_prob\n        expected.append(n_select*prob)\n\n    return expected\n\n\n\n48 Inferring Protein from Spectrum\n\nfrom typing import List\nfrom utils import get_mass\n\ndef protein_infer(L_list: List)-&gt;str:\n    \"\"\"\n        This function returns a protein string of length n−1 whose prefix \n        spectrum is equal to L.\n        -----\n        Parameters:\n        - L_list (List): a list of spectrum\n        -----\n        Returns:\n        - (str) the protein string with prefix spectrum in L\n    \"\"\"\n    mass_dict = get_mass(\"../data/ref/mass.txt\")\n    protein_str = \"\"\n    for i in range(1, len(L_list)):\n        residue = round(float(L_list[i]) - float(L_list[i-1]), 4)\n        for key, value in mass_dict.items():\n            \n            if round(float(value), 4) == residue:\n                protein_str += key\n                break\n    return protein_str\n\n\nwith open(\"../data/rosalind/rosalind_spec.txt\", \"r\") as f:\n    text = f.read()\n    L_list = text.split(\"\\n\")[:-1]\n    print(protein_infer(L_list))\n\nWQSTIMKVNHWIPWIRDGMRHHCKFMWRPSPGGEPREFDFCPMHTMHRRYKFNRASQAEEIKGIPYAHMIITHFQIFCQIYT\n\n\n\n\n49 Comparing Spectra with the Spectral Convolution\n\ndef comparing_spectra(seq_1: List, seq_2:List):\n    \"\"\"\n        This function returns the largest multiplicity and the absolute value of \n        the number maximizing multiplicity.\n        -----\n        Parameters:\n        - seq_1, seq_2 (str): the sequences of positive real numbers\n        -----\n        Returns:\n        - max_value (int): the largest multiplicity \n        - multiplicity (str): the absolute value of the number maximizing multiplicity.\n    \"\"\"\n    difference = {}\n    for num_1 in seq_1:\n        for num_2 in seq_2:\n            diff = float(num_1) - float(num_2)\n            diff = round(diff, 5)\n            if diff not in difference:\n                difference[diff] = 1\n            else:\n                difference[diff] += 1\n    multiplicity = max(difference, key=difference.get)\n    max_value = difference[multiplicity]\n    return max_value, multiplicity\n\n\nwith open(\"../data/rosalind/rosalind_conv.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    seq_1 = [float(num) for num in text[0].split(\" \")]\n    seq_2 = [float(num) for num in text[1].split(\" \")]\n    print(comparing_spectra(seq_1, seq_2))\n\n(18, 578.32165)\n\n\n\n\n50 Inferring Peptide from Full Spectrum\n\ndef peptide_inferrence_spectrum(mass_list: List)-&gt;str:\n    \"\"\"\n        This function infers peptide from the full spectrum list\n        -----\n        Parameters:\n        - mass_list (List): the list of masses of b-ions and y-ions\n        -----\n        Returns:\n        - (str): the protein string inferred\n    \"\"\"\n    mass_dict = get_mass(\"../data/ref/mass.txt\", reverse=True)\n    # print(mass_dict)\n    pr_string = \"\"\n\n    ## get the length of protein string\n    n = (len(mass_list) - 3) // 2\n\n    ## use mass_dict to infer the string\n    i = 1\n    while i &lt; len(mass_list) + 1:\n        for j in range(i + 1, len(mass_list)):\n            diff =  float(mass_list[j]) - float(mass_list[i])\n            diff = round(diff, 3)\n            if diff in mass_dict:\n                i = j - 1\n                pr_string += mass_dict[diff]\n                break\n        if len(pr_string) == n:\n            break\n        i += 1\n\n    return pr_string\n\n\nwith open(\"../data/rosalind/rosalind_full.txt\", \"r\") as file:\n    text = file.read().split(\"\\n\")\n    print(peptide_inferrence_spectrum(text))\n\nGPRLEFEPCRTRSNWQMHYRWKNEYGCYVNRFHNVDNGPANYTWVMMVLCQHENDGEYEKREVYVTYNNMGLRHWLLLLHDA",
    "crumbs": [
      "Rosalind",
      "41-50"
    ]
  }
]